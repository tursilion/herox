Asm994a TMS99000 Assembler - v3.010

                * Asm994a Generated Register Equates
                *
      0000 0000 R0      EQU     0 
      0000 0001 R1      EQU     1 
      0000 0002 R2      EQU     2 
      0000 0003 R3      EQU     3 
      0000 0004 R4      EQU     4 
      0000 0005 R5      EQU     5 
      0000 0006 R6      EQU     6 
      0000 0007 R7      EQU     7 
      0000 0008 R8      EQU     8 
      0000 0009 R9      EQU     9 
      0000 000A R10     EQU     10
      0000 000B R11     EQU     11
      0000 000C R12     EQU     12
      0000 000D R13     EQU     13
      0000 000E R14     EQU     14
      0000 000F R15     EQU     15
                *
   1            ************************
   2            * HeroX - by Tursi     *
   3            * Ported by Tursi      *
   4            ************************
   5            
   6            * VDP Usage:
   7            *
   8            * 0000  02FF
   9            * 0300  037F    SAL  (reg 5, 00-7F, scale >0080, value 06)
  10            * 0380  077F
  11            * 0780  07ff    Sprite motion table (interrupt driven, not movable)
  12            * 0800  0FFF    PDT (reg 4, 0-7, scale >0800, value 01) & SPT (reg 6, 0-7, scale >0800, value 01)
  13            * 1000  101F    CT (reg 3, 00-ff, scale >0040, value 40)
  14            * 1020  1FFF    
  15            * 2000  24FF    SDT (reg 2, 0-F, scale >0400, value 08 (256 bytes extra padding))
  16            * 2500  3FFF    
  17            *
  18            * Register usage
  19            * R0 - Scratch, argument passing
  20            * R1 - Scratch, argument passing
  21            * R2 - Scratch, argument passing
  22            * R3 - Scratch, argument passing
  23            * R4 - >8c00 (vdp write data)
  24            * R5 - wradr function address
  25            * R6 - coinc function address
  26            * R7 - pattern function address
  27            * R8 - Always 1 - don't change it (optimization)
  28            * R9 - motion function address
  29            * R10- Subroutine scratch
  30            * R11- Return address for BL, subroutine usage
  31            * R12- Subroutine scratch
  32            * R13- Subroutine scratch
  33            * R14- Subroutine scratch
  34            * R15- Subroutine scratch (SUB return address)
  35            *
  36            * System Free Scratchpad RAM:
  37            * 00 - 1f - Workspace
  38            * 20 - 49 - available for variables (check with listing)
  39            * 4A - 6D - stack area - probably free
  40            * 6E - 6F - free outside of floating point
  41            * 70 - 7F - GPL status block
  42            * 80 - BF - GPL Stack - free
  43            * C0 - DF - Interrupt workspace
  44            * E0 - FF - GPLWS
  45            
  46            * Subroutine calls
  47            * wradr                 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx (r5)
  48            * coinc                 xxxxxxxxxxxxxxxxxxxxxxxxx                (r6)
  49            * pattern               xxxxxxxxxxxxxxxx                                 (r7)
  50            * motion                xxxxxxxxxxxxxx                                   (r9)
  51            * sound                 xxxxxxxxxxxxxx (now all broken up)
  52            * position              xxxxxxxxxxxxx
  53            * vdpset                xxxxxxxxxxx
  54            * hcharf                xxxxxxxxxx
  55            * locate                xxxxxxxxx
  56            * gchar                 xxxxxx
  57            * vcharf                xxxxx
  58            * vdpcpy                xxxxx
  59            * cdelay                xxxx
  60            * display               xxxx
  61            * pix2char      xxxx
  62            * scan                  xxxx
  63            * spriteadr             xxxx
  64            * hchar                 xxx
  65            * key                   xxx
  66            * char                  xx
  67            * disnum                xx
  68            * DSPRALL               xx
  69            * hchar1                xx
  70            * hcharadr              xx
  71            * CLEAR                 x
  72            * delspr                x
  73            * dispadr               x
  74            * sprite                x
  75            * waitnewkey    x
  76            * 000e                  console ROM keyboard scan, can't inline
  77            * draw                  complex enough to keep separate
  78            * shapes                complex enough to keep separate
  79            
  80            * Variables in RAM
  81            *
  82                    AORG >8320
  83                    
  84            * VARIABLES
  85  8320 0000 LE      bss 2   * level
  86  8322 0000 NM      bss 2   * number men
  87  8324 0000 SC      bss 2   * score
  88  8326 0000 AS      bss 2   * animation state
  89  8328 0000 NW      bss 2   * number wafers collected
  90  832A 0000 A       bss 2   * index loop
  91  832C 0000 B       bss 2   * index loop
  92  832E 0000 qw      bss 2   * temporary
  93  8330 0000 ro      bss 2   * row (usually player, but sprite is authoritative)
  94  8332 0000 co  bss 2       * column (same)
  95  8334 0000 rs  bss 2       * row speed (used for jumping)
  96  8336 0000 cs  bss 2   * column speed (used for jumping)
  97  8338 0000 ij  bss 2   * is jumping (wasteful, but we can afford it)
  98            
  99            * SHARED VARIABLES
 100  833A 0000 SNDDEL  BSS 2                   * SOUND COUNTDOWN DELAY IN FRAMES
 101  833C 0000 ENDVARS BSS 2                   * just dummy so the listing file has an address (do not use)
 102            
 103            * Cartridge Header (if cart, not used for MM)
 104                            AORG >6000
 105            
 106            * PROGRAMS ARE LISTED IN REVERSE ORDER
 107                            
 108  6000 AA01                 DATA >AA01,>0200,>0000,PROG1,>0000,>0000
 108  6002 0200  
 108  6004 0000  
 108  6006 600C  
 108  6008 0000  
 108  600A 0000  
 109  600C 0000 PROG1   DATA >0000,GOGAME,>0548
 109  600E 6106  
 109  6010 0548  
 110  6012 4552                 TEXT 'EROX'
 110  6014 4F58  
 111                            EVEN
 112            
 113            * start in MiniMem RAM range
 114  6016 6106                 DEF GOGAME
 115            * todo: enable when it fits in 4k ;)
 116            *               AORG >7000
 117            
 118  6016 4845 HEROX   TEXT 'HERO'
 118  6018 524F  
 119  601A 80                   BYTE >80
 120  601B 0000                 EVEN
 121                            
 122            PRESSFIRE
 123  601C 5052                 TEXT 'PRESS FIRE BUTTON TO PLAY.'
 123  601E 4553  
 123  6020 5320  
 123  6022 4649  
 123  6024 5245  
 123  6026 2042  
 123  6028 5554  
 123  602A 544F  
 123  602C 4E20  
 123  602E 544F  
 123  6030 2050  
 123  6032 4C41  
 123  6034 592E  
 124  6036 80                   BYTE >80
 125  6037 0000                 EVEN
 126                            
 127            GAMEOVER
 128  6038 4741                 TEXT 'GAME OVER'
 128  603A 4D45  
 128  603C 204F  
 128  603E 5645  
 128  6040 52    
 129  6041 80                   BYTE >80
 130                            EVEN
 131            
 132            BONUS
 133  6042 424F                 TEXT 'BONUS= 100 X'
 133  6044 4E55  
 133  6046 533D  
 133  6048 2031  
 133  604A 3030  
 133  604C 2058  
 134  604E 80                   BYTE >80
 135  604F 0000                 EVEN
 136                            
 137            HELPHELP
 138  6050 4845                 TEXT 'HELP'
 138  6052 4C50  
 139  6054 80                   BYTE >80
 140            FFBYTE
 141  6055 FF                   BYTE >FF
 142                            EVEN
 143                            
 144            CHARDAT1        
 145  6056 1038                 DATA >1038,>1010,>1810,>1018,>1038,>1010,>1810,>2844
 145  6058 1010  
 145  605A 1810  
 145  605C 1018  
 145  605E 1038  
 145  6060 1010  
 145  6062 1810  
 145  6064 2844  
 146  6066 081C                 data >081C,>0808,>1808,>0818,>081C,>0808,>1808,>1422
 146  6068 0808  
 146  606A 1808  
 146  606C 0818  
 146  606E 081C  
 146  6070 0808  
 146  6072 1808  
 146  6074 1422  
 147  6076 243C                 data >243C,>3C3C,>1818,>2424,>0000,>0000,>0000,>1866
 147  6078 3C3C  
 147  607A 1818  
 147  607C 2424  
 147  607E 0000  
 147  6080 0000  
 147  6082 0000  
 147  6084 1866  
 148  6086 0010                 data >0010,>3AFE,>3B11,>0000,>0008,>5C7F,>DC88,>0000
 148  6088 3AFE  
 148  608A 3B11  
 148  608C 0000  
 148  608E 0008  
 148  6090 5C7F  
 148  6092 DC88  
 148  6094 0000  
 149  6096 0000                 DATA >0000,>007E,>FFFF,>FFFF,>FF3C,>42A5,>A542,>3CFF
 149  6098 007E  
 149  609A FFFF  
 149  609C FFFF  
 149  609E FF3C  
 149  60A0 42A5  
 149  60A2 A542  
 149  60A4 3CFF  
 150  60A6 4428                 data >4428,>1010,>7C92,>3810,>183C,>282E,>081C,>3E14
 150  60A8 1010  
 150  60AA 7C92  
 150  60AC 3810  
 150  60AE 183C  
 150  60B0 282E  
 150  60B2 081C  
 150  60B4 3E14  
 151  60B6 1818                 DATA >1818,>3C18,>08F8,>0814,>3030,>7830,>9070,>1028
 151  60B8 3C18  
 151  60BA 08F8  
 151  60BC 0814  
 151  60BE 3030  
 151  60C0 7830  
 151  60C2 9070  
 151  60C4 1028  
 152  60C6 2418                 data >2418,>187E,>99BD,>1818,>081C,>0808,>0C08,>0818
 152  60C8 187E  
 152  60CA 99BD  
 152  60CC 1818  
 152  60CE 081C  
 152  60D0 0808  
 152  60D2 0C08  
 152  60D4 0818  
 153  60D6 0000                 data >0000,>3E22,>2A22,>3E00,>1038,>1010,>F010,>3050
 153  60D8 3E22  
 153  60DA 2A22  
 153  60DC 3E00  
 153  60DE 1038  
 153  60E0 1010  
 153  60E2 F010  
 153  60E4 3050  
 154  60E6 66FF                 data >66FF,>FFFF,>7E3C,>1800
 154  60E8 FFFF  
 154  60EA 7E3C  
 154  60EC 1800  
 155                            
 156            CHARDAT2
 157  60EE FFFE                 data >FFFE,>FFFE,>FFFE,>FFFE,>FFFE,>FCF1,>F1FC,>FEFF
 157  60F0 FFFE  
 157  60F2 FFFE  
 157  60F4 FFFE  
 157  60F6 FFFE  
 157  60F8 FCF1  
 157  60FA F1FC  
 157  60FC FEFF  
 158                            
 159            CHARDAT3
 160  60FE 7E42                 data >7E42,>4242,>7E42,>4242
 160  6100 4242  
 160  6102 7E42  
 160  6104 4242  
 161                    
 162            GOGAME  
 163  6106 0300                 LIMI 0                          * disable interrupts
 163  6108 0000  
 164  610A 02E0                 LWPI >8300                      * set correct workspace
 164  610C 8300  
 165  610E 0208                 LI R8,1                         * we reserve R8 to always be the value '1' to save some memory
 165  6110 0001  
 166  6112 0204                 li r4,>8C00                     * VDPWD
 166  6114 8C00  
 167  6116 0205                 LI R5,wradr                     * R5 for wradr
 167  6118 6C72  
 168  611A 0206                 LI R6,coinc                     * r6 for coinc
 168  611C 6F72  
 169  611E 0207                 LI R7,pattern           * r7 for pattern
 169  6120 6F58  
 170  6122 0209                 li r9,motion            * r9 for motion
 170  6124 6FBE  
 171            
 172            * inline initvdp
 173            * Set GR0 mode similar to XB
 174  6126 020C                 LI R12,>8000
 174  6128 8000  
 175  612A 020D                 LI R13,VDPTAB
 175  612C 6C6A  
 176  612E 020A                 LI R10,8
 176  6130 0008  
 177            INITL1
 178  6132 D83D                 MOVB *R13+,@>8319       * R12 LSB
 178  6134 8319  
 179  6136 0695                 bl *r5
 180  6138 022C                 AI R12,>0100
 180  613A 0100  
 181  613C 060A                 DEC R10
 182  613E 16F9                 JNE INITL1
 183                            
 184  6140 020C                 LI R12,>E100    * 16k, screen on, ints on, magnify 1 (differs from XB)
 184  6142 E100  
 185  6144 D80C                 MOVB R12,@>83d4 * also put VDP R1 at the KSCAN reload
 185  6146 83D4  
 186            
 187            * we won't call CLEAR, user can do that, but we do
 188            * need to wipe the sprite table
 189  6148 020C                 LI R12,>4300
 189  614A 4300  
 190  614C 0695                 bl *r5
 191  614E 06A0                 BL @VDPSETF
 191  6150 6C80  
 192  6152 D080                 BYTE >D0,128
 193            * and the automotion table
 194  6154 020C                 LI R12,>4780
 194  6156 4780  
 195  6158 0695                 bl *r5
 196  615A 06A0                 BL @VDPSETF
 196  615C 6C80  
 197  615E 0080                 BYTE 0,128
 198            * and set the color table to all black on trans
 199  6160 020C                 LI R12,>5000
 199  6162 5000  
 200  6164 0695                 bl *r5
 201  6166 06A0                 BL @VDPSETF
 201  6168 6C80  
 202  616A 1020                 byte >10,32
 203            * AND CLEAR ANY SOUND DELAY COUNTER
 204  616C 04E0                 CLR @SNDDEL
 204  616E 833A  
 205            
 206  6170 0200                 LI R0,>1F00
 206  6172 1F00  
 207  6174 D800                 MOVB R0,@>837A  * automotion limit
 207  6176 837A  
 208            
 209            *1 CALL SCREEN(15)              * in the VDP init
 210            
 211            *10 CALL INIT           - not the XB init, my own sub!
 212            * inline init   
 213            *10005 CALL COLOR(10,7,1,11,14,1,12,2,1,13,11,1)
 214  6178 020C         li r12,>500D
 214  617A 500D  
 215  617C 0695         bl *r5
 216  617E 020C         li r12,CDAT
 216  6180 68B8  
 217  6182 020D         li r13,4
 217  6184 0004  
 218  6186 06A0         bl @vdpcpy
 218  6188 6D64  
 219                    
 220            *10010 RESTORE          * oh, goodie... data
 221            *10020 FOR A=96 TO 114
 222            *10030 READ A$ :: CALL CHAR(A,A$)
 223            *10040 NEXT A
 224  618A 06A0         bl @char
 224  618C 6D4A  
 225  618E 6098         byte 96,152
 226  6190 6056         data chardat1
 227                    
 228            *10050 CALL CHAR(120,"FFFEFFFEFFFEFFFEFFFEFCF1F1FCFEFF")
 229  6192 06A0         bl @char
 229  6194 6D4A  
 230  6196 7810         byte 120,16
 231  6198 60EE         data chardat2
 232                    
 233            *10060 CALL CHAR(128,"7E4242427E424242")
 234  619A 06A0         bl @char
 234  619C 6D4A  
 235  619E 8008         byte 128,8
 236  61A0 60FE         data chardat3
 237            
 238            *10120 SUBEND
 239            
 240            *20 CALL CLEAR
 241            l20
 242  61A2 06A0                 BL @CLEAR
 242  61A4 6C90  
 243            
 244            *25 CALL DELSPRITE(ALL)
 245  61A6 06A0                 BL @DSPRALL
 245  61A8 6DF6  
 246            
 247            *30 CALL MAGNIFY(2)
 248            * already done in the VDP Init
 249            
 250            *40 CALL HCHAR(11,14,105,6)
 251            *50 CALL HCHAR(13,14,105,6)
 252            
 253  61AA 06A0                 bl @hcharf
 253  61AC 6D80  
 254  61AE 0B0E                 byte 11,14,105,6
 254  61B0 6906  
 255  61B2 0D0E                 byte 13,14,105,6
 255  61B4 6906  
 256  61B6 0000                 byte 0,0
 257            
 258            *60 CALL VCHAR(11,14,105,3)
 259            *70 CALL VCHAR(11,19,105,3)
 260            
 261  61B8 06A0                 bl @vcharf
 261  61BA 6E12  
 262  61BC 0B0E                 byte 11,14,105,3
 262  61BE 6903  
 263  61C0 0B13                 byte 11,19,105,3
 263  61C2 6903  
 264  61C4 0000                 byte 0,0
 265            
 266            *80 DISPLAY AT(12,13)SIZE(4):"HERO"
 267  61C6 06A0                 bl @display
 267  61C8 6CBE  
 268  61CA 0C0D                 byte 12,13
 269  61CC 6016                 data herox
 270            
 271            *90 DISPLAY AT(23,1):"PRESS FIRE BUTTON TO PLAY."
 272  61CE 06A0                 bl @display
 272  61D0 6CBE  
 273  61D2 1701                 byte 23,1
 274  61D4 601C                 data pressfire
 275            
 276            *100 CALL KEY(1,K,S)
 277            *110 IF K=18 THEN C=1 :: GOTO 140 (not doing c)
 278            *130 IF K<>18 THEN 100
 279            l100
 280  61D6 06A0                 bl @waitnewkey
 280  61D8 7004  
 281            
 282            *140 LE=1 :: NM=3 :: SC=0
 283  61DA C808         mov r8,@le
 283  61DC 8320  
 284  61DE 0200         li r0,3
 284  61E0 0003  
 285  61E2 C800         mov r0,@nm
 285  61E4 8322  
 286  61E6 04E0         clr @sc
 286  61E8 8324  
 287            
 288            *150 CALL DELSPRITE(ALL)
 289            l150
 290  61EA 06A0         BL @DSPRALL
 290  61EC 6DF6  
 291            
 292            *155 AS=0
 293  61EE 04E0         clr @as
 293  61F0 8326  
 294            
 295            *157 NW=0
 296  61F2 04E0         clr @nw
 296  61F4 8328  
 297            
 298            *160 CALL DRAW(LE) - this is the only call
 299  61F6 06A0         bl @draw
 299  61F8 68BC  
 300            
 301            *162 CALL HCHAR(23,4,97,NM)
 302  61FA 0200         li r0,23
 302  61FC 0017  
 303  61FE 0201         li r1,4
 303  6200 0004  
 304  6202 0202         li r2,97
 304  6204 0061  
 305  6206 C0E0         mov @nm,r3
 305  6208 8322  
 306  620A 06A0         bl @hchar
 306  620C 6DAA  
 307            
 308            *165 DISPLAY AT(24,1):SC
 309  620E C020         mov @sc,r0
 309  6210 8324  
 310  6212 06A0         bl @disnum
 310  6214 6CD2  
 311  6216 1801         byte 24,1
 312            
 313            *170 CALL SHAPES(LE) - this is the only call
 314            l170
 315  6218 06A0         bl @shapes
 315  621A 6A26  
 316            
 317            *180 CALL SPRITE(#1,96,16,152,32)
 318  621C 06A0         bl @sprite
 318  621E 6E5C  
 319  6220 0198         byte 1,152,32,96,15,0
 319  6222 2060  
 319  6224 0F00  
 320            
 321  6226 04E0         clr @rs
 321  6228 8334  
 322  622A 04E0         clr @cs
 322  622C 8336  
 323  622E 04E0         clr @ij
 323  6230 8338  
 324            
 325            *190 CALL KEY(C,K,S) :: IF K<>18 THEN 190 - ignoring c
 326            * note: jump/move is really different now
 327            l190
 328  6232 06A0         bl @waitnewkey
 328  6234 7004  
 329            
 330            *200 CALL COLOR(#1,2)
 331            * Inline SPcolor
 332  6236 020C         LI R12,>4303      * address of sprite 1 color for write
 332  6238 4303  
 333  623A 0695         bl *r5
 334  623C D320         MOVB @>8311,R12    * R8 LSB to R12 MSB for color 1
 334  623E 8311  
 335  6240 D50C         MOVB R12,*r4
 336            
 337            *210 CALL JOYST(C,X,Y)
 338            l210
 339            * new movement code
 340  6242 C020         mov @ij,r0
 340  6244 8338  
 341  6246 133B         jeq l210b
 342            
 343            * handle ongoing jump (or fall)
 344  6248 05A0         inc @rs
 344  624A 8334  
 345  624C C020         mov @rs,r0
 345  624E 8334  
 346  6250 0280         ci r0,12        * max fall speed
 346  6252 000C  
 347  6254 1102         jlt jump2
 348  6256 0460         b @l2000                * die if fall too far
 348  6258 64A4  
 349            jump2
 350  625A C008         mov r8,r0
 351  625C 06A0         bl @position
 351  625E 6EA4  
 352  6260 A0A0         a @cs,r2
 352  6262 8336  
 353  6264 1303         jeq jump2b
 354  6266 0282         ci r2,249
 354  6268 00F9  
 355  626A 1A02         jl jump3
 356            jump2b
 357  626C 60A0         s @cs,r2                * clip to screen edges
 357  626E 8336  
 358            jump3
 359  6270 A060         a @rs,r1
 359  6272 8334  
 360  6274 0281         ci r1,187
 360  6276 00BB  
 361  6278 1105         jlt jump4
 362  627A 0281         ci r1,220       * don't die for wraparound
 362  627C 00DC  
 363  627E 1502         jgt jump4       
 364  6280 0460         b @l2000                * die if fall off bottom
 364  6282 64A4  
 365            jump4
 366  6284 C801         mov r1,@ro
 366  6286 8330  
 367  6288 C802         mov r2,@co
 367  628A 8332  
 368  628C 06A0         bl @locate              * move sprite into place
 368  628E 6E86  
 369            
 370  6290 C020         mov @rs,r0
 370  6292 8334  
 371  6294 110D         jlt jump5               * skip if moving up
 372  6296 06A0         bl @pix2char
 372  6298 7026  
 373  629A 05C0         inct r0
 374  629C 06A0         bl @gchar
 374  629E 6DC4  
 375  62A0 0282         ci r2,32
 375  62A2 0020  
 376  62A4 1305         jeq jump5
 377  62A6 0282         ci r2,112
 377  62A8 0070  
 378  62AA 1302         jeq jump5
 379  62AC 04E0         clr @ij                 * landed
 379  62AE 8338  
 380            jump5
 381  62B0 0696         bl *r6                  * coinc
 382  62B2 C000         mov r0,r0
 383  62B4 1302         jeq jump6
 384  62B6 0460         b @l2000
 384  62B8 64A4  
 385            jump6
 386  62BA 0460         b @l210                 * loop around
 386  62BC 6242  
 387            
 388            * normal movement
 389            l210b
 390  62BE 06A0         bl @scan
 390  62C0 6DD6  
 391            * inline joyst
 392  62C2 04C1         clr r1
 393  62C4 D060         movb @>8377,r1
 393  62C6 8377  
 394  62C8 08A1         sra r1,10       * sign extend, /2!
 395  62CA C801         mov r1,@cs
 395  62CC 8336  
 396  62CE D060         movb @>8376,r1
 396  62D0 8376  
 397  62D2 08A1         sra r1,10       * sign extend, /2!
 398  62D4 C801         mov r1,@rs
 398  62D6 8334  
 399            
 400            * don't have RND, so using sprite 4 col instead
 401            *211 IF LE=5 THEN CALL PATTERN(#2,108+RND)
 402  62D8 C0E0         mov @le,r3
 402  62DA 8320  
 403  62DC 0283         ci r3,5
 403  62DE 0005  
 404  62E0 160D         jne l212
 405  62E2 0200         li r0,4
 405  62E4 0004  
 406  62E6 06A0         bl @position
 406  62E8 6EA4  
 407  62EA 0922         srl r2,2
 408  62EC 0242         andi r2,1
 408  62EE 0001  
 409  62F0 0222         ai r2,108
 409  62F2 006C  
 410  62F4 C042         mov r2,r1
 411  62F6 0200         li r0,2
 411  62F8 0002  
 412  62FA 0697         bl *r7
 413            l212
 414            
 415            *212 IF X=0 AND Y=0 THEN GOTO 300
 416            * omitted for ROM space
 417            
 418            *215 IF X=0 THEN 230
 419  62FC C020         mov @cs,r0
 419  62FE 8336  
 420  6300 131C         jeq l230
 421            
 422            *217 CALL POSITION(#1,RO,CO)
 423  6302 C008         mov r8,r0
 424  6304 06A0         bl @position
 424  6306 6EA4  
 425  6308 C801         mov r1,@ro
 425  630A 8330  
 426  630C C802         mov r2,@co
 426  630E 8332  
 427            
 428            *220 CO=CO+X*2 :: if CO<1 or CO>255 then 225
 429  6310 C0E0         mov @cs,r3
 429  6312 8336  
 430  6314 A083         a r3,r2           * SLA and a 16-bit value don't work for negative
 431  6316 1305         jeq l225          * handles 0
 432  6318 0282         ci r2,248
 432  631A 00F8  
 433  631C 1B02         jh l225           * handles > 248 or negative (255 was uneven)
 434            
 435            *221 CALL LOCATE(#1,RO,CO)
 436  631E 06A0         bl @locate
 436  6320 6E86  
 437            
 438            *225 AS=AS=0
 439            l225
 440  6322 0560         inv @as
 440  6324 8326  
 441            
 442            *228 CALL PATTERN(#1,96-2*(X=-4)-AS)
 443  6326 0201         li r1,96
 443  6328 0060  
 444            *       mov @x,r0       * @X is still in r3
 445  632A C0C3     mov r3,r3
 446  632C 1101     jlt l228c
 447  632E 1601         jne l228b
 448            l228c
 449  6330 05C1         inct r1
 450            l228b
 451  6332 6060         s @as,r1
 451  6334 8326  
 452  6336 C008         mov r8,r0
 453  6338 0697         bl *r7
 454            
 455            *230 IF Y=0 THEN 300
 456            l230
 457  633A C020         mov @rs,r0
 457  633C 8334  
 458  633E 1322         jeq l300
 459            
 460            *250 CALL POSITION(#1,RO,CO)
 461  6340 C008         mov r8,r0
 462  6342 06A0         bl @position
 462  6344 6EA4  
 463  6346 C801         mov r1,@ro
 463  6348 8330  
 464  634A C802         mov r2,@co
 464  634C 8332  
 465            
 466            *260 CALL GCHAR(RO/8+1-2*(Y=-4),CO/8+1,QW)
 467  634E 06A0         bl @pix2char
 467  6350 7026  
 468  6352 C0A0         mov @rs,r2
 468  6354 8334  
 469  6356 1101         jlt l260c
 470  6358 1001         jmp l260b
 471            l260c
 472  635A 05C0         inct r0
 473            l260b
 474  635C 06A0         bl @gchar
 474  635E 6DC4  
 475            
 476            *270 IF QW=128 THEN CALL PATTERN(#1,100) :: CALL POSITION(#1,RO,CO) :: RO=RO-Y*2 :: RO=RO-(RO=0) :: CALL LOCATE(#1,RO,CO)
 477  6360 0282         ci r2,128
 477  6362 0080  
 478  6364 160F         jne l300
 479            
 480  6366 C008         mov r8,r0
 481  6368 0201         li r1,100
 481  636A 0064  
 482  636C 0697         bl *r7
 483                    
 484  636E C008         mov r8,r0
 485  6370 06A0         bl @position
 485  6372 6EA4  
 486            
 487  6374 6060         s @rs,r1
 487  6376 8334  
 488  6378 6060         s @rs,r1
 488  637A 8334  
 489                    
 490  637C 1601         jne l270b
 491  637E 0581         inc r1
 492            l270b
 493            
 494  6380 06A0         bl @locate
 494  6382 6E86  
 495            
 496            *300 CALL KEY(C,K,S) :: IF K<>18 THEN 400
 497            l300
 498  6384 06A0         bl @key      * scan was already done above
 498  6386 6DEC  
 499  6388 0281         ci r1,18
 499  638A 0012  
 500  638C 1302         jeq l300b
 501  638E 0460         b @l400
 501  6390 63AA  
 502            l300b
 503            
 504            *310 REM  JUMP*********
 505            * new code - we just set up the variables
 506  6392 0720         seto @ij
 506  6394 8338  
 507  6396 0200         li r0,-6
 507  6398 FFFA  
 508  639A C800         mov r0,@rs
 508  639C 8334  
 509                    
 510            *330 CALL SOUND(100,-3,15)
 511  639E 0201         li r1,-3
 511  63A0 FFFD  
 512  63A2 0202         li r2,7
 512  63A4 0007  
 513  63A6 06A0         bl @soundvol
 513  63A8 6ED8  
 514            
 515            * check for wafer (thus +2, not +3)
 516            *400 CALL POSITION(#1,RO,CO) :: RO=RO/8+2 :: CO=CO/8+1
 517            * if we got the wafer, do all this
 518            *410 CALL GCHAR(RO,CO,QW) :: IF QW=112 THEN CALL HCHAR(RO,CO,32) :: CALL SOUND(100,550,0) :: NW=NW+1 :: SC=SC+50 :: DISPLAY AT(24,1):SC
 519            l400
 520  63AA C008         mov r8,r0
 521  63AC 06A0         bl @position
 521  63AE 6EA4  
 522  63B0 C801         mov r1,@ro
 522  63B2 8330  
 523  63B4 C802         mov r2,@co
 523  63B6 8332  
 524  63B8 06A0         bl @pix2char
 524  63BA 7026  
 525  63BC 0580         inc r0
 526  63BE C800         mov r0,@ro
 526  63C0 8330  
 527  63C2 C801         mov r1,@co
 527  63C4 8332  
 528            
 529  63C6 06A0         bl @gchar
 529  63C8 6DC4  
 530  63CA C802         mov r2,@qw
 530  63CC 832E  
 531                    
 532  63CE 0282         ci r2,112
 532  63D0 0070  
 533  63D2 1617         jne l410b
 534                    
 535  63D4 C020         mov @ro,r0              * erase wafer
 535  63D6 8330  
 536  63D8 C060         mov @co,r1
 536  63DA 8332  
 537  63DC 0202         li r2,32
 537  63DE 0020  
 538  63E0 06A0         bl @hchar1
 538  63E2 6DA8  
 539                    
 540  63E4 0201         li r1,550               * make tone
 540  63E6 0226  
 541  63E8 06A0         bl @sound100
 541  63EA 6EC6  
 542                    
 543  63EC 05A0         inc @nw                 * count collected wafers
 543  63EE 8328  
 544                    
 545  63F0 0200         li r0,50                * add to score
 545  63F2 0032  
 546  63F4 A800         a r0,@sc
 546  63F6 8324  
 547                    
 548  63F8 C020         mov @sc,r0              * display new score
 548  63FA 8324  
 549  63FC 06A0         bl @disnum
 549  63FE 6CD2  
 550  6400 1801         byte 24,1
 551            l410b
 552            
 553            * check for ladder appearance (easier to cheat if it's not after the inc)
 554            *420 IF NW<4 THEN 440
 555  6402 C020         mov @nw,r0
 555  6404 8328  
 556  6406 0280         ci r0,4
 556  6408 0004  
 557  640A 1A20         jl l440
 558                    
 559            * Check if ladder (fixed location) needs to be drawn
 560            * any object there prevents it!
 561            *421 CALL GCHAR(1,5,QW) :: IF QW<>32 THEN 440
 562  640C C008         mov r8,r0
 563  640E 0201         li r1,5
 563  6410 0005  
 564  6412 06A0         bl @gchar
 564  6414 6DC4  
 565  6416 0282         ci r2,32
 565  6418 0020  
 566  641A 1618         jne l440
 567            
 568            * set up loop to draw ladder as far as necessary
 569            *425 RO=1 :: CO=5
 570  641C C808         mov r8,@ro
 570  641E 8330  
 571  6420 0200         li r0,5
 571  6422 0005  
 572  6424 C800         mov r0,@co
 572  6426 8332  
 573            
 574            * the actual loop is here - draw till we hit something (anything)
 575            *430 CALL GCHAR(RO,CO,QW) :: IF QW=32 THEN CALL HCHAR(RO,CO,128) :: RO=RO+1 :: GOTO 430
 576            l430
 577  6428 C020         mov @ro,r0
 577  642A 8330  
 578  642C C060         mov @co,r1
 578  642E 8332  
 579  6430 06A0         bl @gchar
 579  6432 6DC4  
 580  6434 0282         ci r2,32
 580  6436 0020  
 581  6438 1607         jne l430b
 582                    
 583  643A 0202         li r2,128
 583  643C 0080  
 584  643E 06A0         bl @hchar1
 584  6440 6DA8  
 585                    
 586  6442 05A0         inc @ro
 586  6444 8330  
 587  6446 10F0         jmp l430
 588            l430b   
 589            
 590            * main game loops around here
 591            *435 GOTO 210
 592            l435
 593  6448 0460         b @l210
 593  644A 6242  
 594            
 595            * if no ladder draw, then we come here
 596            * if row (character) is less than 3, then we must have climbed to the top - do win routine
 597            * todo: change to require punching bad guy, then ladder to damsel appears
 598            * - but only if we have space. It's not bad as-is
 599            * - ladder routine will need a separate draw for the final stage
 600            *440 IF RO<3 THEN 1000
 601            l440
 602  644C C020         mov @ij,r0
 602  644E 8338  
 603  6450 1605         jne l440b     * not if jumping
 604  6452 C020         mov @ro,r0
 604  6454 8330  
 605  6456 0280         ci r0,3
 605  6458 0003  
 606  645A 1A19         jl l1000
 607            l440b
 608            
 609            * check for ground underneath character - if none, fall (32 or 112)
 610            * and then try to step off it.
 611            *450 CALL GCHAR(RO+1,CO,QW) :: IF QW=32 THEN 2000
 612  645C C020         mov @ro,r0
 612  645E 8330  
 613  6460 0580         inc r0
 614  6462 C060         mov @co,r1
 614  6464 8332  
 615  6466 06A0         bl @gchar
 615  6468 6DC4  
 616  646A 0282         ci r2,32
 616  646C 0020  
 617  646E 1304         jeq l450b
 618  6470 0282         ci r2,112
 618  6472 0070  
 619  6474 1301         jeq l450b
 620  6476 1004         jmp l450c
 621            l450b
 622  6478 0720         seto @ij                * start falling
 622  647A 8338  
 623  647C 04E0         clr @rs                 * zero gravity to start
 623  647E 8334  
 624            l450c
 625            
 626            *460 CALL COINC(ALL,QW) :: IF QW THEN 2000
 627  6480 0696         bl *r6
 628  6482 C000         mov r0,r0
 629  6484 1302         jeq l460b
 630  6486 0460         b @l2000
 630  6488 64A4  
 631            l460b
 632                    
 633            *470 GOTO 210
 634  648A 0460         b @l210
 634  648C 6242  
 635                    
 636            *1000 REM  NEXT LEVEL
 637            l1000
 638            
 639            *1010 LE=LE+1
 640  648E 05A0         inc @le
 640  6490 8320  
 641                    
 642            *1015 IF LE=6 THEN 4000
 643  6492 C020         mov @le,r0
 643  6494 8320  
 644  6496 0280         ci r0,6
 644  6498 0006  
 645  649A 1602         jne l1015b
 646  649C 0460         b @l4000
 646  649E 6594  
 647            l1015b
 648            
 649            *1020 GOTO 150
 650  64A0 0460         b @l150
 650  64A2 61EA  
 651                    
 652            *2000 REM  DIED!
 653            l2000
 654            
 655            *2005 FOR A=4 TO 16 :: CALL MOTION(#A,0,0) :: NEXT A
 656  64A4 0200         li r0,4
 656  64A6 0004  
 657  64A8 C800         mov r0,@a
 657  64AA 832A  
 658            l2005b
 659  64AC C020         mov @a,r0
 659  64AE 832A  
 660  64B0 0280         ci r0,16
 660  64B2 0010  
 661  64B4 1B08         jh l2005c
 662                    
 663  64B6 C020         mov @a,r0
 663  64B8 832A  
 664  64BA 04C1         clr r1
 665  64BC 04C2         clr r2
 666  64BE 0699         bl *r9
 667                    
 668  64C0 05A0         inc @a
 668  64C2 832A  
 669  64C4 10F3         jmp l2005b
 670            l2005c
 671            
 672            * I like it the way it is, sound effect, then fall. Lets you see what killed you.
 673            *2010 FOR A=990 TO 110 STEP-110 :: CALL SOUND(-100,A,0) :: NEXT A
 674  64C6 0200         li r0,990
 674  64C8 03DE  
 675  64CA C800         mov r0,@a
 675  64CC 832A  
 676            l2010b
 677  64CE C020         mov @a,r0
 677  64D0 832A  
 678  64D2 0280         ci r0,110
 678  64D4 006E  
 679  64D6 1A0A         jl l2010c
 680                    
 681  64D8 C060         mov @a,r1
 681  64DA 832A  
 682  64DC 06A0         bl @soundn100
 682  64DE 6ECC  
 683  64E0 0696         bl *r6          * delay
 684                    
 685  64E2 0200         li r0,-110
 685  64E4 FF92  
 686  64E6 A800         a r0,@a
 686  64E8 832A  
 687  64EA 10F1         jmp l2010b
 688            l2010c
 689            
 690            * falling here
 691            *2020 CALL PATTERN(#1,106) :: CALL MOTION(#1,16,0)
 692  64EC C008         mov r8,r0
 693  64EE 0201         li r1,106
 693  64F0 006A  
 694  64F2 0697         bl *r7
 695                    
 696  64F4 0201         li r1,16
 696  64F6 0010  
 697  64F8 04C2         clr r2
 698  64FA 0699         bl *r9
 699            
 700            *2030 CALL POSITION(#1,RO,CO) :: IF RO<200 THEN 2030
 701            l2030   
 702  64FC 0696         bl *r6                  * we insert a coinc call to make our framing work
 703  64FE C008         mov r8,r0
 704  6500 06A0         bl @position
 704  6502 6EA4  
 705  6504 0281         ci r1,200
 705  6506 00C8  
 706  6508 1AF9         jl l2030
 707            
 708            *2040 CALL DELSPRITE(ALL)
 709  650A 06A0         bl @dsprall
 709  650C 6DF6  
 710                    
 711            *2045 CALL HCHAR(23,4,32,5)
 712  650E 06A0         bl @hcharf
 712  6510 6D80  
 713  6512 1704         byte 23,4,32,5,0,0
 713  6514 2005  
 713  6516 0000  
 714            
 715            *2050 NM=NM-1 :: CALL HCHAR(23,4,97,NM)
 716  6518 0620         dec @nm
 716  651A 8322  
 717  651C 0200         li r0,23
 717  651E 0017  
 718  6520 0201         li r1,4
 718  6522 0004  
 719  6524 0202         li r2,97
 719  6526 0061  
 720  6528 C0E0         mov @nm,r3
 720  652A 8322  
 721  652C 06A0         bl @hchar
 721  652E 6DAA  
 722            
 723            *2060 IF NM=0 THEN 3000
 724  6530 C020         mov @nm,r0
 724  6532 8322  
 725  6534 1302         jeq l3000
 726            
 727            *2070 GOTO 170
 728  6536 0460         b @l170
 728  6538 6218  
 729                    
 730            * game over!    
 731            *3000 FOR A=1990 TO 110 STEP-110 :: CALL SOUND(-100,A,0,A*2,0) :: NEXT A
 732            l3000
 733  653A 0200         li r0,1990
 733  653C 07C6  
 734  653E C800         mov r0,@a
 734  6540 832A  
 735            l3000b
 736  6542 C020         mov @a,r0
 736  6544 832A  
 737  6546 0280         ci r0,110
 737  6548 006E  
 738  654A 1A0A         jl l3000c
 739                    
 740  654C C060         mov @a,r1
 740  654E 832A  
 741            * voice 2 not supported yet
 742  6550 06A0         bl @soundn100
 742  6552 6ECC  
 743  6554 0696         bl *r6                  * delay
 744                    
 745  6556 0200         li r0,-110
 745  6558 FF92  
 746  655A A800         a r0,@a
 746  655C 832A  
 747  655E 10F1         jmp l3000b
 748            l3000c
 749            
 750            *3010 DISPLAY AT(12,8):"GAME OVER"
 751  6560 06A0         bl @display
 751  6562 6CBE  
 752  6564 0C0A         byte 12,10
 753  6566 6038         data gameover
 754                    
 755            *3020 FOR A=1 TO 50 :: CALL KEY(C,K,S)
 756  6568 C808         mov r8,@a
 756  656A 832A  
 757            l3020b
 758  656C C020         mov @a,r0
 758  656E 832A  
 759  6570 0280         ci r0,50
 759  6572 0032  
 760  6574 1B0D         jh l3040b
 761            
 762  6576 0696         bl *r6                  * slow it down a bit, this is just a timeout delay
 763  6578 06A0         bl @scan
 763  657A 6DD6  
 764  657C 06A0         bl @key
 764  657E 6DEC  
 765                    
 766            *3030 IF K=18 THEN 20
 767  6580 0281         ci r1,18
 767  6582 0012  
 768  6584 1602         jne l3040
 769  6586 0460         b @l20
 769  6588 61A2  
 770                    
 771            *3040 NEXT A :: GOTO 20
 772            l3040
 773  658A 05A0         inc @a
 773  658C 832A  
 774  658E 10EE         jmp l3020b
 775            l3040b
 776  6590 0460         b @l20
 776  6592 61A2  
 777                    
 778            * play a little win chime       
 779            *4000 FOR A=550 TO 1010 STEP 110 :: CALL SOUND(-100,A,0) :: NEXT A
 780            l4000
 781  6594 0200         li r0,550
 781  6596 0226  
 782  6598 C800         mov r0,@a
 782  659A 832A  
 783            l4000b
 784  659C C020         mov @a,r0
 784  659E 832A  
 785  65A0 0280         ci r0,1010
 785  65A2 03F2  
 786  65A4 1B0A         jh l4000c
 787                    
 788  65A6 C060         mov @a,r1
 788  65A8 832A  
 789  65AA 06A0         bl @soundn100
 789  65AC 6ECC  
 790  65AE 0696         bl *r6          * delay
 791                    
 792  65B0 0200         li r0,110
 792  65B2 006E  
 793  65B4 A800         a r0,@a
 793  65B6 832A  
 794  65B8 10F1         jmp l4000b
 795            l4000c
 796            
 797            * back down the ladder
 798            *4010 FOR A=1 TO 4 :: CALL POSITION(#1,RO,CO) :: CALL LOCATE(#1,RO+8,CO) :: FOR B=1 TO 40 :: NEXT B :: NEXT A
 799  65BA C808         mov r8,@a
 799  65BC 832A  
 800            l4010b
 801  65BE C020         mov @a,r0
 801  65C0 832A  
 802  65C2 0280         ci r0,4
 802  65C4 0004  
 803  65C6 1B0B         jh l4010c
 804                    
 805  65C8 C008         mov r8,r0
 806  65CA 06A0         bl @position
 806  65CC 6EA4  
 807  65CE 0221         ai r1,8
 807  65D0 0008  
 808  65D2 06A0         bl @locate
 808  65D4 6E86  
 809                    
 810  65D6 0696         bl *r6                          * coinc for delay instead
 811                    
 812  65D8 05A0         inc @a
 812  65DA 832A  
 813  65DC 10F0         jmp l4010b
 814            l4010c
 815            
 816            *4015 CALL PATTERN(#1,99)
 817  65DE C008         mov r8,r0
 818  65E0 0201         li r1,99
 818  65E2 0063  
 819  65E4 0697         bl *r7
 820            
 821            * walk to the villian
 822            *4020 FOR A=1 TO 13 :: CALL POSITION(#1,RO,CO) :: CALL LOCATE(#1,RO,CO-8) :: CALL PATTERN(#1,98+AN) :: AN=-(AN=0) :: FOR B=1 TO 40 :: NEXT B :: NEXT A
 823  65E6 C808         mov r8,@a
 823  65E8 832A  
 824            l4020b
 825  65EA C020         mov @a,r0
 825  65EC 832A  
 826  65EE 0280         ci r0,13
 826  65F0 000D  
 827  65F2 1B13         jh l4020c
 828                    
 829  65F4 C008         mov r8,r0
 830  65F6 06A0         bl @position
 830  65F8 6EA4  
 831  65FA 0222         ai r2,-8
 831  65FC FFF8  
 832  65FE 06A0         bl @locate
 832  6600 6E86  
 833                    
 834  6602 C008         mov r8,r0
 835  6604 0201         li r1,98
 835  6606 0062  
 836  6608 6060         s @as,r1                        * screw AN, I'm using AS
 836  660A 8326  
 837  660C 0697         bl *r7
 838                    
 839  660E 0560         inv @as
 839  6610 8326  
 840                    
 841  6612 0696         bl *r6                  * coinc for delay instead
 842                    
 843  6614 05A0         inc @a
 843  6616 832A  
 844  6618 10E8         jmp l4020b
 845            l4020c
 846                    
 847            * prepare to punch
 848            *4030 CALL PATTERN(#1,111) :: FOR A=1 TO 200 :: NEXT A
 849  661A C008         mov r8,r0
 850  661C 0201         li r1,111
 850  661E 006F  
 851  6620 0697         bl *r7
 852            
 853  6622 0200         li r0,5
 853  6624 0005  
 854  6626 06A0         bl @cdelay
 854  6628 6FB2  
 855            
 856            * punch
 857            *4040 CALL PATTERN(#1,113) :: CALL SOUND(100,-6,10)
 858  662A C008         mov r8,r0
 859  662C 0201         li r1,113
 859  662E 0071  
 860  6630 0697         bl *r7
 861                    
 862  6632 0201         li r1,-6
 862  6634 FFFA  
 863  6636 0202         li r2,5
 863  6638 0005  
 864  663A 06A0         bl @soundvol
 864  663C 6ED8  
 865  663E 0696         bl *r6                  * delay
 866            
 867            * drop villian
 868            *4050 CALL PATTERN(#2,110) :: CALL MOTION(#2,18,0)
 869  6640 0200         li r0,2
 869  6642 0002  
 870  6644 0201         li r1,110
 870  6646 006E  
 871  6648 0697         bl *r7
 872                    
 873  664A 0201         li r1,18
 873  664C 0012  
 874  664E 04C2         clr r2
 875  6650 0699         bl *r9
 876            
 877  6652 0696         bl *r6                  * delay
 878            
 879            * unpunch
 880            *4060 CALL PATTERN(#1,98)
 881  6654 C008         mov r8,r0
 882  6656 0201         li r1,98
 882  6658 0062  
 883  665A 0697         bl *r7
 884            
 885            * wait for villian fall to end
 886            *4070 CALL POSITION(#2,RO,CO) :: IF RO<200 THEN 4070
 887            l4070
 888  665C 0696         bl *r6                  * run plus delay
 889            
 890  665E 0200         li r0,2
 890  6660 0002  
 891  6662 06A0         bl @position
 891  6664 6EA4  
 892  6666 0281         ci r1,200
 892  6668 00C8  
 893  666A 1AF8         jl l4070
 894            
 895            * delete villian
 896            *4080 CALL DELSPRITE(#2)
 897  666C 0200         li r0,2
 897  666E 0002  
 898  6670 06A0         bl @delspr
 898  6672 6FDE  
 899                    
 900            * move up to machine    
 901            *4090 CALL POSITION(#1,RO,CO) :: CALL LOCATE(#1,RO,CO-8)
 902  6674 C008         mov r8,r0
 903  6676 06A0         bl @position
 903  6678 6EA4  
 904  667A C801         mov r1,@ro
 904  667C 8330  
 905  667E C802         mov r2,@co
 905  6680 8332  
 906  6682 0222         ai r2,-8
 906  6684 FFF8  
 907  6686 06A0         bl @locate
 907  6688 6E86  
 908  668A 0696         bl *r6
 909            
 910            *4100 CALL LOCATE(#1,RO,CO-16)
 911  668C C008         mov r8,r0
 912  668E C060         mov @ro,r1
 912  6690 8330  
 913  6692 C0A0         mov @co,r2
 913  6694 8332  
 914  6696 0222         ai r2,-16
 914  6698 FFF0  
 915  669A 06A0         bl @locate
 915  669C 6E86  
 916  669E 0696         bl *r6
 917                    
 918            * wait  
 919            *4110 FOR A=1 TO 200 :: NEXT A
 920  66A0 0200         li r0,5
 920  66A2 0005  
 921  66A4 06A0         bl @cdelay
 921  66A6 6FB2  
 922                    
 923            * display '?'   
 924            *4120 CALL HCHAR(4,5,63) :: FOR A=1 TO 300 :: NEXT A :: CALL HCHAR(4,5,32)
 925  66A8 06A0         bl @hcharf
 925  66AA 6D80  
 926  66AC 0405         byte 4,5,63,1,0,0
 926  66AE 3F01  
 926  66B0 0000  
 927                    
 928  66B2 0200         li r0,7
 928  66B4 0007  
 929  66B6 06A0         bl @cdelay
 929  66B8 6FB2  
 930                    
 931  66BA 06A0         bl @hcharf
 931  66BC 6D80  
 932  66BE 0405         byte 4,5,32,1,0,0
 932  66C0 2001  
 932  66C2 0000  
 933                    
 934  66C4 0696         bl *r6
 935            
 936            * prepare to punch
 937            *4130 CALL PATTERN(#1,111)
 938  66C6 C008         mov r8,r0
 939  66C8 0201         li r1,111
 939  66CA 006F  
 940  66CC 0697         bl *r7
 941            
 942            *4140 FOR A=1 TO 50 :: NEXT A
 943  66CE 0696         bl *r6
 944            
 945            * punch
 946            *4150 CALL PATTERN(#1,113)
 947  66D0 C008         mov r8,r0
 948  66D2 0201         li r1,113
 948  66D4 0071  
 949  66D6 0697         bl *r7
 950                    
 951            *4160 CALL SOUND(100,-6,4)
 952  66D8 0201         li r1,-6
 952  66DA FFFA  
 953  66DC 0202         li r2,2
 953  66DE 0002  
 954  66E0 06A0         bl @soundvol
 954  66E2 6ED8  
 955  66E4 0696         bl *r6
 956                    
 957            * break machine and unpunch     
 958            *4170 CALL HCHAR(6,3,121) :: CALL PATTERN(#1,98)
 959            * erase 'help'
 960            *4175 DISPLAY AT(1,10):"    ";
 961  66E6 06A0         bl @hcharf
 961  66E8 6D80  
 962  66EA 0603         byte 6,3,121,1
 962  66EC 7901  
 963  66EE 010C         byte 1,12,32,4,0,0
 963  66F0 2004  
 963  66F2 0000  
 964                    
 965  66F4 C008         mov r8,r0
 966  66F6 0201         li r1,98
 966  66F8 0062  
 967  66FA 0697         bl *r7
 968                    
 969            * turn off all the enemies      
 970            *4180 FOR A=4 TO 16 :: CALL DELSPRITE(#A) :: NEXT A
 971  66FC 0200         li r0,4
 971  66FE 0004  
 972  6700 C800         mov r0,@a
 972  6702 832A  
 973            l4180b
 974  6704 C020         mov @a,r0
 974  6706 832A  
 975  6708 0280         ci r0,16
 975  670A 0010  
 976  670C 1B05         jh l4180c
 977                    
 978  670E 06A0         bl @delspr
 978  6710 6FDE  
 979                    
 980  6712 05A0         inc @a
 980  6714 832A  
 981  6716 10F6         jmp l4180b
 982            l4180c
 983            
 984            * move back to ladder
 985            *4190 FOR A=1 TO 15 :: CALL PATTERN(#1,96+AN) :: AN=-(AN=0) :: CALL POSITION(#1,RO,CO) :: CALL LOCATE(#1,RO,CO+8) :: FOR B=1 TO 50 :: NEXT B :: NEXT A
 986  6718 C808         mov r8,@a
 986  671A 832A  
 987            l4190b  
 988  671C C020         mov @a,r0
 988  671E 832A  
 989  6720 0280         ci r0,15
 989  6722 000F  
 990  6724 1B13         jh l4190c
 991                    
 992  6726 C008         mov r8,r0
 993  6728 0201         li r1,96
 993  672A 0060  
 994  672C 6060         s @as,r1
 994  672E 8326  
 995  6730 0697         bl *r7
 996                    
 997  6732 0560         inv @as
 997  6734 8326  
 998                    
 999  6736 C008         mov r8,r0
1000  6738 06A0         bl @position
1000  673A 6EA4  
1001  673C 0222         ai r2,8
1001  673E 0008  
1002  6740 06A0         bl @locate
1002  6742 6E86  
1003                    
1004  6744 0696         bl *r6
1005                    
1006  6746 05A0         inc @a
1006  6748 832A  
1007  674A 10E8         jmp l4190b
1008            l4190c
1009            
1010            *4200 CALL PATTERN(#1,100)
1011  674C C008         mov r8,r0
1012  674E 0201         li r1,100
1012  6750 0064  
1013  6752 0697         bl *r7
1014                    
1015            * move up ladder
1016            *4210 FOR A=1 TO 4 :: CALL POSITION(#1,RO,CO) :: CALL LOCATE(#1,RO-8,CO) :: FOR B=1 TO 20 :: NEXT B :: NEXT A
1017  6754 C808         mov r8,@a
1017  6756 832A  
1018            l4210b
1019  6758 C020         mov @a,r0
1019  675A 832A  
1020  675C 0280         ci r0,4
1020  675E 0004  
1021  6760 1B0B         jh l4210c
1022                    
1023  6762 C008         mov r8,r0
1024  6764 06A0         bl @position
1024  6766 6EA4  
1025  6768 0221         ai r1,-8
1025  676A FFF8  
1026  676C 06A0         bl @locate
1026  676E 6E86  
1027                    
1028  6770 0696         bl *r6
1029                    
1030  6772 05A0         inc @a
1030  6774 832A  
1031  6776 10F0         jmp l4210b
1032            l4210c
1033            
1034            *4220 CALL PATTERN(#1,98)
1035  6778 C008         mov r8,r0
1036  677A 0201         li r1,98
1036  677C 0062  
1037  677E 0697         bl *r7
1038            
1039            * move to girl
1040            *4230 FOR A=1 TO 4 :: CALL POSITION(#3,RO,CO) :: CALL LOCATE(#3,RO,CO-8) :: FOR B=1 TO 75 :: NEXT B :: NEXT A
1041  6780 C808         mov r8,@a
1041  6782 832A  
1042            l4230b
1043  6784 C020         mov @a,r0
1043  6786 832A  
1044  6788 0280         ci r0,4
1044  678A 0004  
1045  678C 1B0C         jh l4230c
1046                    
1047  678E C008         mov r8,r0
1048  6790 06A0         bl @position
1048  6792 6EA4  
1049  6794 0222         ai r2,-8
1049  6796 FFF8  
1050  6798 06A0         bl @locate
1050  679A 6E86  
1051                    
1052  679C 0696         bl *r6
1053  679E 0696         bl *r6
1054                    
1055  67A0 05A0         inc @a
1055  67A2 832A  
1056  67A4 10EF         jmp l4230b
1057            l4230c
1058            
1059            * heart <3
1060            *4240 CALL SPRITE(#4,114,9,1,94)
1061  67A6 06A0         bl @sprite
1061  67A8 6E5C  
1062  67AA 0401         byte 4,1,94,114,8,0
1062  67AC 5E72  
1062  67AE 0800  
1063            
1064            *4250 B=330
1065  67B0 0200         li r0,330
1065  67B2 014A  
1066  67B4 C800         mov r0,@b
1066  67B6 832C  
1067                    
1068            * pointless happy tune  
1069            *4260 FOR A=1 TO 3
1070  67B8 C808         mov r8,@a
1070  67BA 832A  
1071            l4260b
1072  67BC C020         mov @a,r0
1072  67BE 832A  
1073  67C0 0280         ci r0,3
1073  67C2 0003  
1074  67C4 1B17         jh l4320b
1075            
1076            *4270 CALL SOUND(300,B,0)
1077  67C6 C060         mov @b,r1
1077  67C8 832C  
1078  67CA 06A0         bl @sound300
1078  67CC 6ED2  
1079                    
1080            *4280 CALL SOUND(300,B+55,0)
1081  67CE 0221         ai r1,55
1081  67D0 0037  
1082  67D2 06A0         bl @sound300
1082  67D4 6ED2  
1083            
1084            *4290 CALL SOUND(300,B+20,0)
1085  67D6 0221         ai r1,-35
1085  67D8 FFDD  
1086  67DA 06A0         bl @sound300
1086  67DC 6ED2  
1087                    
1088            *4300 CALL SOUND(300,B+75,0)
1089  67DE 0221         ai r1,55
1089  67E0 0037  
1090  67E2 06A0         bl @sound300
1090  67E4 6ED2  
1091                    
1092            *4310 B=B+110
1093  67E6 0200         li r0,110
1093  67E8 006E  
1094  67EA A800         a r0,@b
1094  67EC 832C  
1095                    
1096            *4320 NEXT A
1097  67EE 05A0         inc @a
1097  67F0 832A  
1098  67F2 10E4         jmp l4260b
1099            l4320b
1100            
1101            *4330 CALL SOUND(300,B+110,0)
1102  67F4 C060         mov @b,r1
1102  67F6 832C  
1103  67F8 0221         ai r1,110
1103  67FA 006E  
1104  67FC 06A0         bl @sound300
1104  67FE 6ED2  
1105                    
1106            *4340 CALL SOUND(300,B,0)
1107  6800 0221         ai r1,-110
1107  6802 FF92  
1108  6804 06A0         bl @sound300
1108  6806 6ED2  
1109                    
1110            *4350 CALL SOUND(300,B-110,0)
1111  6808 0221         ai r1,-110
1111  680A FF92  
1112  680C 06A0         bl @sound300
1112  680E 6ED2  
1113                    
1114            *4360 FOR A=1 TO 300 :: NEXT A
1115  6810 0200         li r0,7
1115  6812 0007  
1116  6814 06A0         bl @cdelay
1116  6816 6FB2  
1117                    
1118            *4370 DISPLAY AT(9,10):"BONUS= 100 X"
1119  6818 06A0         bl @display
1119  681A 6CBE  
1120  681C 090A         byte 9,10
1121  681E 6042         data bonus
1122            
1123            *4380 CO=25
1124  6820 0200         li r0,25
1124  6822 0019  
1125  6824 C800         mov r0,@co
1125  6826 8332  
1126                    
1127            *4390 FOR A=1 TO NM :: CALL SOUND(100,1000,0) :: CALL HCHAR(9,CO,97) :: SC=SC+100 :: DISPLAY AT(24,1):SC
1128  6828 C808         mov r8,@a
1128  682A 832A  
1129            l4390b
1130  682C C020         mov @a,r0
1130  682E 832A  
1131  6830 8800         c r0,@nm
1131  6832 8322  
1132  6834 1B2B         jh l4400b
1133                    
1134  6836 0201         li r1,1000
1134  6838 03E8  
1135  683A 06A0         bl @sound100
1135  683C 6EC6  
1136                    
1137  683E 0200         li r0,9
1137  6840 0009  
1138  6842 C060         mov @co,r1
1138  6844 8332  
1139  6846 0202         li r2,97
1139  6848 0061  
1140  684A 06A0         bl @hchar1
1140  684C 6DA8  
1141                    
1142  684E 0200         li r0,100
1142  6850 0064  
1143  6852 A800         a r0,@sc
1143  6854 8324  
1144                    
1145  6856 C020         mov @sc,r0
1145  6858 8324  
1146  685A 06A0         bl @disnum
1146  685C 6CD2  
1147  685E 1801         byte 24,1
1148                    
1149            *4400 CALL HCHAR(23,4,32,5) :: NM=NM-1 :: CALL HCHAR(23,4,97,NM) :: CO=CO+1 :: NEXT A
1150  6860 06A0         bl @hcharf
1150  6862 6D80  
1151  6864 1704         byte 23,4,32,5,0,0
1151  6866 2005  
1151  6868 0000  
1152                    
1153  686A 0620         dec @nm
1153  686C 8322  
1154                    
1155  686E 0200         li r0,23
1155  6870 0017  
1156  6872 0201         li r1,4
1156  6874 0004  
1157  6876 0202         li r2,97
1157  6878 0061  
1158  687A C0E0         mov @nm,r3
1158  687C 8322  
1159  687E 06A0         bl @hchar
1159  6880 6DAA  
1160                    
1161  6882 05A0         inc @co
1161  6884 8332  
1162                    
1163  6886 05A0         inc @a
1163  6888 832A  
1164  688A 10D0         jmp l4390b
1165            l4400b
1166                    
1167            *4410 FOR A=1 TO 1000 :: CALL KEY(C,K,S) :: IF K=18 THEN 20
1168  688C C808         mov r8,@a
1168  688E 832A  
1169            l4410b
1170  6890 C020         mov @a,r0
1170  6892 832A  
1171  6894 0280         ci r0,1000
1171  6896 03E8  
1172  6898 1B0D         jh l4420b
1173                    
1174  689A 0696         bl *r6                  * slow it down a bit, this is just a timeout delay
1175  689C 06A0         bl @scan
1175  689E 6DD6  
1176  68A0 06A0         bl @key
1176  68A2 6DEC  
1177  68A4 0281         ci r1,18
1177  68A6 0012  
1178  68A8 1602         jne l4420
1179  68AA 0460         b @l20
1179  68AC 61A2  
1180            
1181            *4420 NEXT A :: GOTO 20
1182            l4420
1183  68AE 05A0         inc @a
1183  68B0 832A  
1184  68B2 10EE         jmp l4410b
1185            l4420b
1186  68B4 0460         b @l20
1186  68B6 61A2  
1187                    
1188            * replacing subs with gosub...
1189            
1190            *10000 SUB INIT
1191  68B8 60D0 CDAT BYTE >60,>D0,>10,>a0
1191  68BA 10A0  
1192            
1193            *10130 SUB DRAW(X) - always LE
1194            DRAW
1195  68BC C3CB         mov r11,r15
1196            
1197            *10135 CALL CLEAR
1198  68BE 06A0         bl @clear
1198  68C0 6C90  
1199                    
1200            *10140 ON X GOTO 10160,10300,10400,10500,10600
1201  68C2 C020         mov @le,r0
1201  68C4 8320  
1202  68C6 0600         dec r0
1203  68C8 0A10         sla r0,1
1204  68CA 0220         ai r0,JTABLE
1204  68CC 68D2  
1205  68CE C010         mov *r0,r0
1206  68D0 0450         b *r0
1207            
1208            JTABLE
1209  68D2 68DC         DATA l10160,l10300,l10400,l10500,l10600
1209  68D4 6916  
1209  68D6 6948  
1209  68D8 698A  
1209  68DA 69E8  
1210            
1211            *10160 CALL HCHAR(5,1,105,32)
1212            *10170 CALL HCHAR(10,1,105,32)
1213            *10180 CALL HCHAR(15,1,105,32)
1214            *10190 CALL HCHAR(22,1,105,32)
1215            *10240 CALL HCHAR(4,5,112)
1216            *10250 CALL HCHAR(9,30,112)
1217            *10260 CALL HCHAR(14,3,112)
1218            *10270 CALL HCHAR(21,30,112)
1219            l10160
1220  68DC 06A0         bl @hcharf
1220  68DE 6D80  
1221  68E0 0501         byte 5,1,105,32
1221  68E2 6920  
1222  68E4 0A01         byte 10,1,105,32
1222  68E6 6920  
1223  68E8 0F01         byte 15,1,105,32
1223  68EA 6920  
1224  68EC 1601         byte 22,1,105,32
1224  68EE 6920  
1225  68F0 0405         byte 4,5,112,1
1225  68F2 7001  
1226  68F4 091E         byte 9,30,112,1
1226  68F6 7001  
1227  68F8 0E03         byte 14,3,112,1
1227  68FA 7001  
1228  68FC 151E         byte 21,30,112,1
1228  68FE 7001  
1229  6900 0000         byte 0,0
1230                            
1231            *10210 CALL VCHAR(4,29,128,6)
1232            *10220 CALL VCHAR(9,4,128,6)
1233            *10230 CALL VCHAR(14,29,128,8)
1234  6902 06A0         bl @vcharf
1234  6904 6E12  
1235  6906 041D         byte 4,29,128,6
1235  6908 8006  
1236  690A 0904         byte 9,4,128,6
1236  690C 8006  
1237  690E 0E1D         byte 14,29,128,8
1237  6910 8008  
1238  6912 0000         byte 0,0
1239                    
1240            *10280 SUBEXIT
1241  6914 045F         b *r15
1242                    
1243            *10300 CALL HCHAR(5,1,105,32)
1244            *10310 CALL HCHAR(10,1,105,32)
1245            *10320 CALL HCHAR(15,1,105,32)
1246            *10330 CALL HCHAR(22,1,105,32)
1247            *10350 CALL HCHAR(4,27,112)
1248            *10360 CALL HCHAR(9,27,112)
1249            *10370 CALL HCHAR(14,27,112)
1250            *10380 CALL HCHAR(21,27,112)
1251            l10300
1252  6916 06A0         bl @hcharf
1252  6918 6D80  
1253  691A 0501         byte 5,1,105,32
1253  691C 6920  
1254  691E 0A01         byte 10,1,105,32
1254  6920 6920  
1255  6922 0F01         byte 15,1,105,32
1255  6924 6920  
1256  6926 1601         byte 22,1,105,32
1256  6928 6920  
1257  692A 041B         byte 4,27,112,1
1257  692C 7001  
1258  692E 091B         byte 9,27,112,1
1258  6930 7001  
1259  6932 0E1B         byte 14,27,112,1
1259  6934 7001  
1260  6936 151B         byte 21,27,112,1
1260  6938 7001  
1261  693A 0000         byte 0,0
1262            
1263            *10340 CALL VCHAR(3,5,128,19)
1264  693C 06A0         bl @vcharf
1264  693E 6E12  
1265  6940 0305         byte 3,5,128,19
1265  6942 8013  
1266  6944 0000         byte 0,0
1267                    
1268            *10390 SUBEXIT
1269  6946 045F         b *r15
1270                    
1271            *10400 CALL HCHAR(4,1,105,32)
1272            *10405 CALL HCHAR(10,1,105,32)
1273            *10410 CALL HCHAR(17,1,105,32)
1274            *10415 CALL HCHAR(22,3,105,6)
1275            *10420 CALL HCHAR(21,11,105,6)
1276            *10425 CALL HCHAR(20,19,105,6)
1277            *10445 CALL HCHAR(3,31,112)
1278            *10450 CALL HCHAR(9,2,112)
1279            *10455 CALL HCHAR(16,30,112)
1280            *10460 CALL HCHAR(20,14,112)
1281            l10400
1282  6948 06A0         bl @hcharf
1282  694A 6D80  
1283  694C 0401         byte 4,1,105,32
1283  694E 6920  
1284  6950 0A01         byte 10,1,105,32
1284  6952 6920  
1285  6954 1101         byte 17,1,105,32
1285  6956 6920  
1286  6958 1603         byte 22,3,105,6
1286  695A 6906  
1287  695C 150B         byte 21,11,105,6
1287  695E 6906  
1288  6960 1413         byte 20,19,105,6
1288  6962 6906  
1289  6964 031F         byte 3,31,112,1
1289  6966 7001  
1290  6968 0902         byte 9,2,112,1
1290  696A 7001  
1291  696C 101E         byte 16,30,112,1
1291  696E 7001  
1292  6970 140E         byte 20,14,112,1
1292  6972 7001  
1293  6974 0000         byte 0,0
1294                    
1295            *10430 CALL VCHAR(3,29,128,7)
1296            *10435 CALL VCHAR(9,4,128,8)
1297            *10440 CALL VCHAR(16,23,128,4)
1298  6976 06A0         bl @vcharf
1298  6978 6E12  
1299  697A 031D         byte 3,29,128,7
1299  697C 8007  
1300  697E 0904         byte 9,4,128,8
1300  6980 8008  
1301  6982 1017         byte 16,23,128,4
1301  6984 8004  
1302  6986 0000         byte 0,0
1303                    
1304            *10465 SUBEXIT
1305  6988 045F         b *r15
1306            
1307            *10500 CALL HCHAR(4,7,105,12)
1308            *10505 CALL HCHAR(4,21,105,4)
1309            *10510 CALL HCHAR(4,27,105,4)
1310            *10515 CALL HCHAR(7,3,105,6)
1311            *10520 CALL HCHAR(7,11,105,20)
1312            *10525 CALL HCHAR(10,1,105,32)
1313            *10530 CALL HCHAR(14,3,105,22)
1314            *10535 CALL HCHAR(14,27,105,4)
1315            *10540 CALL HCHAR(20,15,105,10)
1316            *10545 CALL HCHAR(21,9,105,10)
1317            *10550 CALL HCHAR(22,3,105,10)
1318            *10575 CALL HCHAR(13,4,112)
1319            *10580 CALL HCHAR(6,28,112)
1320            *10585 CALL HCHAR(3,23,112)
1321            *10590 CALL HCHAR(3,29,112)
1322            l10500
1323  698A 06A0         bl @hcharf
1323  698C 6D80  
1324  698E 0407         byte 4,7,105,12
1324  6990 690C  
1325  6992 0415         byte 4,21,105,4
1325  6994 6904  
1326  6996 041B         byte 4,27,105,4
1326  6998 6904  
1327  699A 0703         byte 7,3,105,6
1327  699C 6906  
1328  699E 070B         byte 7,11,105,20
1328  69A0 6914  
1329  69A2 0A01         byte 10,1,105,32
1329  69A4 6920  
1330  69A6 0E03         byte 14,3,105,22
1330  69A8 6916  
1331  69AA 0E1B         byte 14,27,105,4
1331  69AC 6904  
1332  69AE 140F         byte 20,15,105,10
1332  69B0 690A  
1333  69B2 1509         byte 21,9,105,10
1333  69B4 690A  
1334  69B6 1603         byte 22,3,105,10
1334  69B8 690A  
1335  69BA 0D04         byte 13,4,112,1
1335  69BC 7001  
1336  69BE 061C         byte 6,28,112,1
1336  69C0 7001  
1337  69C2 0317         byte 3,23,112,1
1337  69C4 7001  
1338  69C6 031D         byte 3,29,112,1
1338  69C8 7001  
1339  69CA 0000         byte 0,0
1340                    
1341            *10555 CALL VCHAR(3,8,128,4)
1342            *10560 CALL VCHAR(6,5,128,4)
1343            *10565 CALL VCHAR(9,29,128,5)
1344            *10570 CALL VCHAR(13,23,128,7)
1345            *10573 CALL VCHAR(3,30,128,4)
1346  69CC 06A0         bl @vcharf
1346  69CE 6E12  
1347  69D0 0308         byte 3,8,128,4
1347  69D2 8004  
1348  69D4 0605         byte 6,5,128,4
1348  69D6 8004  
1349  69D8 091D         byte 9,29,128,5
1349  69DA 8005  
1350  69DC 0D17         byte 13,23,128,7
1350  69DE 8007  
1351  69E0 031E         byte 3,30,128,4
1351  69E2 8004  
1352  69E4 0000         byte 0,0
1353                    
1354            *10595 SUBEXIT
1355  69E6 045F         b *r15
1356                    
1357            *10600 CALL HCHAR(3,9,105,12)
1358            *10605 CALL HCHAR(7,3,105,28)
1359            *10610 CALL HCHAR(12,3,105,28)
1360            *10615 CALL HCHAR(17,3,105,28)
1361            *10620 CALL HCHAR(22,3,105,28)
1362            l10600
1363  69E8 06A0         bl @hcharf
1363  69EA 6D80  
1364  69EC 0309         byte 3,9,105,12
1364  69EE 690C  
1365  69F0 0703         byte 7,3,105,28
1365  69F2 691C  
1366  69F4 0C03         byte 12,3,105,28
1366  69F6 691C  
1367  69F8 1103         byte 17,3,105,28
1367  69FA 691C  
1368  69FC 1603         byte 22,3,105,28
1368  69FE 691C  
1369  6A00 0000         byte 0,0
1370            
1371            *10625 CALL VCHAR(2,19,128,5)
1372            *10630 CALL VCHAR(6,29,128,6)
1373            *10635 CALL VCHAR(11,4,128,6)
1374            *10640 CALL VCHAR(16,29,128,6)
1375            *10645 CALL VCHAR(4,3,120,3)
1376  6A02 06A0         bl @vcharf
1376  6A04 6E12  
1377  6A06 0213         byte 2,19,128,5
1377  6A08 8005  
1378  6A0A 061D         byte 6,29,128,6
1378  6A0C 8006  
1379  6A0E 0B04         byte 11,4,128,6
1379  6A10 8006  
1380  6A12 101D         byte 16,29,128,6
1380  6A14 8006  
1381  6A16 0403         byte 4,3,120,3
1381  6A18 7803  
1382  6A1A 0000         byte 0,0
1383                    
1384            *10650 DISPLAY AT(1,10):"HELP"
1385  6A1C 06A0         bl @display
1385  6A1E 6CBE  
1386  6A20 010A         byte 1,10
1387  6A22 6050         data helphelp
1388                    
1389            *10655 SUBEND
1390  6A24 045F         b *r15
1391                    
1392            *10700 SUB SHAPES(X) - always 'LE'
1393            SHAPES
1394  6A26 C28B         mov r11,r10
1395            
1396            *10710 ON X GOTO 10720,10800,10900,11000,12000
1397  6A28 C020         mov @le,r0
1397  6A2A 8320  
1398  6A2C 0600         dec r0
1399  6A2E 0A10         sla r0,1
1400  6A30 0220         ai r0,JTAB2
1400  6A32 6A38  
1401  6A34 C010         mov *r0,r0
1402  6A36 0450         b *r0
1403                    
1404  6A38 6A42 JTAB2 data l10720,l10800,l10900,l11000,l12000
1404  6A3A 6ABC  
1404  6A3C 6B26  
1404  6A3E 6B98  
1404  6A40 6BF8  
1405            
1406            *10720 FOR A=1 TO 3 :: CALL SPRITE(#A+3,101,5,16,A*80,0,5) :: NEXT A
1407            *10730 FOR A=1 TO 3 :: CALL SPRITE(#A+6,101,5,56,A*80,0,-5) :: NEXT A
1408            *10740 FOR A=1 TO 3 :: CALL SPRITE(#A+9,101,5,96,A*80,0,5) :: NEXT A
1409            *10750 FOR A=1 TO 3 :: CALL SPRITE(#A+12,101,5,152,A*80,0,-5) :: NEXT A
1410            *10760 SUBEXIT
1411            
1412            l10720
1413  6A42 020C         li r12,>430c
1413  6A44 430C  
1414  6A46 0695         bl *r5
1415  6A48 020C         li r12,SDAT1
1415  6A4A 6A8C  
1416  6A4C 020D         li r13,48
1416  6A4E 0030  
1417  6A50 06A0         bl @vdpcpy
1417  6A52 6D64  
1418                    
1419  6A54 020C         LI R12,>478C
1419  6A56 478C  
1420  6A58 0695         bl *r5
1421  6A5A 06A0         BL @VDPSETF
1421  6A5C 6C80  
1422  6A5E 0080         byte 0,128
1423                    
1424  6A60 020C         LI R12,>478D
1424  6A62 478D  
1425  6A64 020D         LI R13,>0500
1425  6A66 0500  
1426  6A68 020E         LI R14,3
1426  6A6A 0003  
1427  6A6C 020F         li r15,4
1427  6A6E 0004  
1428            
1429            * write 4 sets of three, inverting 5/-5 each time
1430            l10720b
1431  6A70 0695         bl *r5
1432  6A72 022C         ai r12,4
1432  6A74 0004  
1433  6A76 D50D         movb r13,*r4
1434  6A78 060E         dec r14
1435  6A7A 16FA         jne l10720b
1436  6A7C 020E         li r14,3
1436  6A7E 0003  
1437  6A80 054D         inv r13
1438  6A82 022D         ai r13,>0100            * byte-wise neg
1438  6A84 0100  
1439  6A86 060F         dec r15
1440  6A88 16F3         jne l10720b
1441                    
1442  6A8A 045A         b *r10
1443            
1444            SDAT1
1445  6A8C 0E50         BYTE 14,80,101,5,14,160,101,5,14,240,101,5
1445  6A8E 6505  
1445  6A90 0EA0  
1445  6A92 6505  
1445  6A94 0EF0  
1445  6A96 6505  
1446  6A98 3650         byte 54,80,101,5,54,160,101,5,54,240,101,5
1446  6A9A 6505  
1446  6A9C 36A0  
1446  6A9E 6505  
1446  6AA0 36F0  
1446  6AA2 6505  
1447  6AA4 5E50         byte 94,80,101,5,94,160,101,5,94,240,101,5      
1447  6AA6 6505  
1447  6AA8 5EA0  
1447  6AAA 6505  
1447  6AAC 5EF0  
1447  6AAE 6505  
1448  6AB0 9650         byte 150,80,101,5,150,160,101,5,150,240,101,5   
1448  6AB2 6505  
1448  6AB4 96A0  
1448  6AB6 6505  
1448  6AB8 96F0  
1448  6ABA 6505  
1449            
1450            *10800 FOR A=1 TO 2 :: CALL SPRITE(#A+3,101,5,16,A*100,0,5) :: NEXT A
1451            *10810 FOR A=1 TO 2 :: CALL SPRITE(#A+5,101,5,56,A*100,0,-5)
1452            *10815 NEXT A
1453            *10820 FOR A=1 TO 2 :: CALL SPRITE(#A+7,101,5,96,A*100,0,5) :: NEXT A
1454            *10830 FOR A=1 TO 2 :: CALL SPRITE(#A+9,101,5,152,A*100,0,-5) :: NEXT A
1455            *10840 SUBEXIT
1456            
1457            l10800
1458  6ABC 020C         li r12,>430c
1458  6ABE 430C  
1459  6AC0 0695         bl *r5
1460  6AC2 020C         li r12,SDAT2
1460  6AC4 6B06  
1461  6AC6 020D         li r13,32
1461  6AC8 0020  
1462  6ACA 06A0         bl @vdpcpy
1462  6ACC 6D64  
1463                    
1464  6ACE 020C         LI R12,>478C
1464  6AD0 478C  
1465  6AD2 0695         bl *r5
1466  6AD4 06A0         BL @VDPSETF
1466  6AD6 6C80  
1467  6AD8 0080         byte 0,128
1468                    
1469  6ADA 020C         LI R12,>478D
1469  6ADC 478D  
1470  6ADE 020D         LI R13,>0500
1470  6AE0 0500  
1471  6AE2 020E         LI R14,2
1471  6AE4 0002  
1472  6AE6 020F         li r15,4
1472  6AE8 0004  
1473            
1474            * write 4 sets of two, inverting 5/-5 each time
1475            l10800b
1476  6AEA 0695         bl *r5
1477  6AEC 022C         ai r12,4
1477  6AEE 0004  
1478  6AF0 D50D         movb r13,*r4
1479  6AF2 060E         dec r14
1480  6AF4 16FA         jne l10800b
1481  6AF6 020E         li r14,2
1481  6AF8 0002  
1482  6AFA 054D         inv r13
1483  6AFC 022D         ai r13,>0100            * byte-wise neg
1483  6AFE 0100  
1484  6B00 060F         dec r15
1485  6B02 16F3         jne l10800b
1486                    
1487  6B04 045A         b *r10
1488            
1489            SDAT2
1490  6B06 0E64         byte 14,100,101,5,14,200,101,5
1490  6B08 6505  
1490  6B0A 0EC8  
1490  6B0C 6505  
1491  6B0E 3664         byte 54,100,101,5,54,200,101,5
1491  6B10 6505  
1491  6B12 36C8  
1491  6B14 6505  
1492  6B16 5E64         byte 94,100,101,5,94,200,101,5
1492  6B18 6505  
1492  6B1A 5EC8  
1492  6B1C 6505  
1493  6B1E 9664         byte 150,100,101,5,150,200,101,5
1493  6B20 6505  
1493  6B22 96C8  
1493  6B24 6505  
1494            
1495            *10900 FOR A=1 TO 3 :: CALL SPRITE(#A+3,101,5,8,A*80,0,5) :: NEXT A
1496            *10910 FOR A=1 TO 3 :: CALL SPRITE(#A+6,101,5,56,A*80,0,-5) :: NEXT A
1497            *10920 FOR A=1 TO 3 :: CALL SPRITE(#A+9,101,5,112,A*80,0,5) :: NEXT A
1498            *10930 CALL SPRITE(#13,103,3,136,100,0,-5)
1499            *10940 SUBEXIT
1500            
1501            l10900
1502  6B26 020C         li r12,>430c
1502  6B28 430C  
1503  6B2A 0695         bl *r5
1504  6B2C 020C         li r12,SDAT3
1504  6B2E 6B70  
1505  6B30 020D         li r13,40
1505  6B32 0028  
1506  6B34 06A0         bl @vdpcpy
1506  6B36 6D64  
1507                    
1508  6B38 020C         LI R12,>478C
1508  6B3A 478C  
1509  6B3C 0695         bl *r5
1510  6B3E 06A0         BL @VDPSETF
1510  6B40 6C80  
1511  6B42 0080         byte 0,128
1512                    
1513  6B44 020C         LI R12,>478D
1513  6B46 478D  
1514  6B48 020D         LI R13,>0500
1514  6B4A 0500  
1515  6B4C 020E         LI R14,3
1515  6B4E 0003  
1516  6B50 020F         li r15,4
1516  6B52 0004  
1517            
1518            * write 4 sets of three, inverting 5/-5 each time
1519            l10900b
1520  6B54 0695         bl *r5                          * note: only 1 sprite in the last set, hopefully won't break ;)
1521  6B56 022C         ai r12,4
1521  6B58 0004  
1522  6B5A D50D         movb r13,*r4
1523  6B5C 060E         dec r14
1524  6B5E 16FA         jne l10900b
1525  6B60 020E         li r14,3
1525  6B62 0003  
1526  6B64 054D         inv r13
1527  6B66 022D         ai r13,>0100            * byte-wise neg
1527  6B68 0100  
1528  6B6A 060F         dec r15
1529  6B6C 16F3         jne l10900b
1530                    
1531  6B6E 045A         b *r10
1532            
1533            SDAT3
1534  6B70 0650         byte 6,80,101,5,6,160,101,5,6,240,101,5
1534  6B72 6505  
1534  6B74 06A0  
1534  6B76 6505  
1534  6B78 06F0  
1534  6B7A 6505  
1535  6B7C 3650         byte 54,80,101,5,54,160,101,5,54,240,101,5
1535  6B7E 6505  
1535  6B80 36A0  
1535  6B82 6505  
1535  6B84 36F0  
1535  6B86 6505  
1536  6B88 6E50         byte 110,80,101,5,110,160,101,5,110,240,101,5
1536  6B8A 6505  
1536  6B8C 6EA0  
1536  6B8E 6505  
1536  6B90 6EF0  
1536  6B92 6505  
1537  6B94 8664         byte 134,100,103,3
1537  6B96 6703  
1538            
1539            *11000 CALL SPRITE(#4,101,14,8,100)
1540            *11010 CALL SPRITE(#6,103,3,32,100,0,-5)
1541            *11020 FOR A=1 TO 3 :: CALL SPRITE(#A+6,101,5,56,A*80,0,5) :: NEXT A
1542            *11030 CALL SPRITE(#10,103,3,88,80,0,-5)
1543            *11040 SUBEXIT
1544            
1545            l11000
1546  6B98 020C         li r12,>430c
1546  6B9A 430C  
1547  6B9C 0695         bl *r5
1548  6B9E 020C         li r12,SDAT4
1548  6BA0 6BDC  
1549  6BA2 020D         li r13,28
1549  6BA4 001C  
1550  6BA6 06A0         bl @vdpcpy
1550  6BA8 6D64  
1551                    
1552  6BAA 020C         LI R12,>478C
1552  6BAC 478C  
1553  6BAE 0695         bl *r5
1554  6BB0 06A0         BL @VDPSETF
1554  6BB2 6C80  
1555  6BB4 0080         byte 0,128
1556                    
1557  6BB6 0200         li r0,6
1557  6BB8 0006  
1558  6BBA 04C1         clr r1
1559  6BBC 0202         li r2,-5
1559  6BBE FFFB  
1560  6BC0 0699         bl *r9
1561  6BC2 0200         li r0,10
1561  6BC4 000A  
1562  6BC6 0699         bl *r9
1563  6BC8 0200         li r0,7
1563  6BCA 0007  
1564  6BCC 0202         li r2,5
1564  6BCE 0005  
1565  6BD0 0699         bl *r9
1566  6BD2 0580         inc r0
1567  6BD4 0699         bl *r9
1568  6BD6 0580         inc r0
1569  6BD8 0699         bl *r9
1570                    
1571  6BDA 045A         b *r10
1572            
1573            SDAT4
1574  6BDC 0664         byte 6,100,101,13,>d2,0,0,0,30,100,103,2
1574  6BDE 650D  
1574  6BE0 D200  
1574  6BE2 0000  
1574  6BE4 1E64  
1574  6BE6 6702  
1575  6BE8 3650         byte 54,80,101,4,54,160,101,4,54,240,101,4
1575  6BEA 6504  
1575  6BEC 36A0  
1575  6BEE 6504  
1575  6BF0 36F0  
1575  6BF2 6504  
1576  6BF4 5650         byte 86,80,103,2
1576  6BF6 6702  
1577            
1578            *12000 CALL SPRITE(#2,108,2,32,24)
1579            *12010 CALL SPRITE(#3,107,10,1,72)
1580            *12020 CALL SPRITE(#4,102,3,56,100,0,5)
1581            *12030 FOR A=1 TO 2 :: CALL SPRITE(#A+4,104,15,81,A*80,0,-5) :: NEXT A
1582            *12040 CALL SPRITE(#7,103,3,96,100,0,-5)
1583            *12050 CALL SPRITE(#8,104,15,121,100,0,5)
1584            *12060 CALL SPRITE(#9,102,3,136,50,0,5)
1585            *12070 CALL SPRITE(#10,104,15,161,100,0,-5)
1586            *12080 SUBEND
1587            
1588            l12000
1589  6BF8 020C         li r12,>4304
1589  6BFA 4304  
1590  6BFC 0695         bl *r5
1591  6BFE 020C         li r12,SDAT5
1591  6C00 6C46  
1592  6C02 020D         li r13,36
1592  6C04 0024  
1593  6C06 06A0         bl @vdpcpy
1593  6C08 6D64  
1594                    
1595  6C0A 020C         LI R12,>4784
1595  6C0C 4784  
1596  6C0E 0695         bl *r5
1597  6C10 06A0         BL @VDPSETF
1597  6C12 6C80  
1598  6C14 0080         byte 0,128
1599            
1600  6C16 0200         li r0,4
1600  6C18 0004  
1601  6C1A 04C1         clr r1
1602  6C1C 0202         li r2,5
1602  6C1E 0005  
1603  6C20 0699         bl *r9
1604  6C22 0200         li r0,8
1604  6C24 0008  
1605  6C26 0699         bl *r9
1606  6C28 0580         inc r0
1607  6C2A 0699         bl *r9
1608  6C2C 0202         li r2,-5
1608  6C2E FFFB  
1609  6C30 0200         li r0,5
1609  6C32 0005  
1610  6C34 0699         bl *r9
1611  6C36 0580         inc r0
1612  6C38 0699         bl *r9
1613  6C3A 0580         inc r0
1614  6C3C 0699         bl *r9
1615  6C3E 0200         li r0,10
1615  6C40 000A  
1616  6C42 0699         bl *r9
1617                    
1618  6C44 045A         b *r10
1619            
1620            SDAT5
1621  6C46 1E18         byte 30,24,108,1,>ff,72,107,9,54,100,102,2
1621  6C48 6C01  
1621  6C4A FF48  
1621  6C4C 6B09  
1621  6C4E 3664  
1621  6C50 6602  
1622  6C52 4F50         byte 79,80,104,14,79,160,104,14
1622  6C54 680E  
1622  6C56 4FA0  
1622  6C58 680E  
1623  6C5A 5E64         byte 94,100,103,2,119,100,104,14,134,50,102,2
1623  6C5C 6702  
1623  6C5E 7764  
1623  6C60 680E  
1623  6C62 8632  
1623  6C64 6602  
1624  6C66 9F64         byte 159,100,104,14
1624  6C68 680E  
1625            
1626            **********************************
1627            * Extended BASIC Porting support *
1628            * by Tursi                       *
1629            **********************************
1630            
1631            ************************************
1632            * VDP support for the XB functions *
1633            ************************************
1634            
1635            * non-bitmap mode, ext video off
1636            * 16k, screen on, ints on, magnify 1 (differs from XB)
1637            * different from XB - SDT at >2000
1638            * different from XB - CT at >1000
1639            * different from XB - PDT at >0800
1640            * SAT at >0300 (motion table at >0780, fixed)
1641            * different from XB - SPT at >0800
1642            * transparent on XB color 15
1643  6C6A 00E1 VDPTAB  DATA >00E1,>0840,>0106,>010E
1643  6C6C 0840  
1643  6C6E 0106  
1643  6C70 010E  
1644            
1645            * write address - R12 has word ready to write with tags
1646  6C72 06CC WRADR   SWPB R12
1647  6C74 D80C                 MOVB R12,@>8C02
1647  6C76 8C02  
1648  6C78 06CC                 SWPB R12
1649  6C7A D80C                 MOVB R12,@>8C02
1649  6C7C 8C02  
1650  6C7E 045B                 B *R11
1651                            
1652            * vdpsetf takes the byte and the count as bytes after the call
1653            * count of 255 or fewer bytes
1654            VDPSETF
1655  6C80 D33B                 movb *r11+,R12
1656  6C82 04CD                 clr r13
1657  6C84 D83B                 movb *r11+,@>811B       * r13 LSB
1657  6C86 811B  
1658            * write byte in R12 MSB R13 times to VDP
1659  6C88 D50C VDPSET  MOVB R12,*r4
1660  6C8A 060D                 DEC R13
1661  6C8C 16FD                 JNE VDPSET
1662  6C8E 045B                 B *R11
1663            
1664            * XB-LIKE FUNCTIONS - REGS 0+ FOR INPUTS, BL TO CALL
1665            * MUST PRESERVE REGS, BUT CAN USE R10,R12-R14
1666            
1667  6C90 020C CLEAR   LI R12,>6000
1667  6C92 6000  
1668  6C94 C38B                 MOV R11,R14
1669  6C96 0695                 bl *r5
1670  6C98 020C                 LI R12,>2000
1670  6C9A 2000  
1671  6C9C 020D                 LI R13,>500   * 512 bytes padding for jump wraparound
1671  6C9E 0500  
1672  6CA0 06A0                 BL @VDPSET
1672  6CA2 6C88  
1673  6CA4 045E                 B *R14
1674                            
1675            * DISPADR - Set the write VDP address for a display function
1676            * 1=ROW+1,2=COL-1 (28 col print)
1677            * followed by data bytes, row,col, data
1678            * r14 is the parent pointer
1679            DISPADR
1680  6CA6 04CC                 clr r12
1681  6CA8 D83E                 movb *R14+,@>8319       * r12 LSB
1681  6CAA 8319  
1682  6CAC 060C                 DEC R12
1683  6CAE 0A5C                 SLA R12,5
1684  6CB0 B83E                 ab *r14+,@>8319         * I think this should always be safe, no wrap
1684  6CB2 8319  
1685  6CB4 058C                 INC R12
1686  6CB6 026C                 ORI R12,>6000
1686  6CB8 6000  
1687  6CBA 0460                 B @WRADR                * just branch, so it returns for us
1687  6CBC 6C72  
1688                            
1689            *DISPLAY        0=STRING (>80 TERMINATED),1=ROW+1,2=COL-1 (28 col print)
1690            * data: row,col,address
1691  6CBE C38B DISPLAY MOV R11,R14
1692  6CC0 06A0                 BL @DISPADR
1692  6CC2 6CA6  
1693  6CC4 C33E                 MOV *r14+,R12
1694  6CC6 04CD                 CLR R13
1695  6CC8 D37C DSLP1   MOVB *R12+,R13
1696  6CCA 1102                 JLT DSEXIT
1697  6CCC D50D                 MOVB R13,*r4
1698  6CCE 10FC                 JMP DSLP1
1699  6CD0 045E DSEXIT  B *R14
1700            
1701            *DISNUM 0=NUMBER TO PRINT,1=ROW+1,2=COL-1 (28 col print)
1702            * r0 is number, but row and col are bytes after the call
1703  6CD2 C38B DISNUM  MOV R11,R14
1704  6CD4 06A0                 BL @DISPADR
1704  6CD6 6CA6  
1705  6CD8 04CA                 CLR R10                 * Use as flag
1706  6CDA C340                 MOV R0,R13
1707  6CDC 04CC                 CLR R12                 * prepare for DIV
1708  6CDE 020B                 LI R11,10000    * we can use R11 now ;)
1708  6CE0 2710  
1709  6CE2 3F0B                 DIV R11,R12             * R12=result, R13=remainder
1710  6CE4 C30C                 MOV R12,R12
1711  6CE6 1305                 JEQ SKIP01
1712  6CE8 022C                 AI R12,48
1712  6CEA 0030  
1713  6CEC 06CC                 SWPB R12
1714  6CEE D50C                 MOVB R12,*r4
1715  6CF0 070A                 SETO R10                * don't need to test on the first digit
1716  6CF2 020B SKIP01  LI R11,1000
1716  6CF4 03E8  
1717  6CF6 04CC                 CLR R12
1718  6CF8 3F0B                 DIV R11,R12
1719  6CFA C30C                 MOV R12,R12
1720  6CFC 1602                 JNE NSKP1
1721  6CFE C28A                 MOV R10,R10
1722  6D00 1305                 JEQ SKIP02
1723  6D02 022C NSKP1   AI R12,48
1723  6D04 0030  
1724  6D06 06CC                 SWPB R12
1725  6D08 D50C                 MOVB R12,*r4
1726  6D0A 070A                 SETO R10
1727  6D0C 020B SKIP02  LI R11,100
1727  6D0E 0064  
1728  6D10 04CC                 CLR R12
1729  6D12 3F0B                 DIV R11,R12
1730  6D14 C30C                 MOV R12,R12
1731  6D16 1602                 JNE NSKP2
1732  6D18 C28A                 MOV R10,R10
1733  6D1A 1305                 JEQ SKIP03
1734  6D1C 022C NSKP2   AI R12,48
1734  6D1E 0030  
1735  6D20 06CC                 SWPB R12
1736  6D22 D50C                 MOVB R12,*r4
1737  6D24 070A                 SETO R10
1738  6D26 020B SKIP03  LI R11,10
1738  6D28 000A  
1739  6D2A 04CC                 CLR R12
1740  6D2C 3F0B                 DIV R11,R12
1741  6D2E C30C                 MOV R12,R12
1742  6D30 1602                 JNE NSKP3
1743  6D32 C28A                 MOV R10,R10
1744  6D34 1305                 JEQ SKIP04
1745  6D36 022C NSKP3   AI R12,48
1745  6D38 0030  
1746  6D3A 06CC                 SWPB R12
1747  6D3C D50C                 MOVB R12,*r4
1748  6D3E 070A                 SETO R10
1749  6D40 022D SKIP04  AI R13,48               * always print the last digit
1749  6D42 0030  
1750  6D44 06CD                 SWPB R13
1751  6D46 D50D                 MOVB R13,*r4
1752  6D48 045E                 B *R14
1753                            
1754            *CHAR   0=CHAR, 1=NUMBER OF BYTES, 2=ADDRESS OF BYTES
1755            * Data statements after the call
1756  6D4A C38B CHAR    MOV R11,R14
1757  6D4C 04CC                 clr r12
1758  6D4E D83E                 movb *r14+,@>8319       * r12 LSB
1758  6D50 8319  
1759  6D52 0A3C                 SLA R12,3
1760  6D54 022C                 AI R12,>4800
1760  6D56 4800  
1761  6D58 0695 CHAR1   bl *r5
1762  6D5A 04CD                 clr r13
1763  6D5C D83E                 movb *r14+,@>831b       * r13 LSB
1763  6D5E 831B  
1764  6D60 C33E                 mov *r14+,r12
1765  6D62 C2CE                 MOV R14,R11             * make the below reusable
1766            * VDP Copy - source in R12, count in R13, VDP already set
1767  6D64 D53C VDPCPY  MOVB *R12+,*r4
1768  6D66 060D                 DEC R13
1769  6D68 16FD                 JNE VDPCPY
1770  6D6A 045B                 B *R11
1771                            
1772            * HCHARADR (also for vchar, gchar, etc)
1773            * R0,R1 to R12 for read
1774            HCHARADR
1775  6D6C C300                 MOV R0,R12
1776  6D6E 060C                 DEC R12
1777  6D70 024C                 ANDI R12,>00FF
1777  6D72 00FF  
1778  6D74 0A5C                 SLA R12,5
1779  6D76 A301                 A R1,R12
1780  6D78 060C                 DEC R12
1781  6D7A 022C                 AI R12,>2000
1781  6D7C 2000  
1782  6D7E 045B                 B *R11
1783                            
1784            * HCHARF - fixed value hchar
1785            * the four values, as bytes, are at the return address
1786            * we have a lot of hchars... count==0 is illegal
1787            * continues till it finds a 0 byte for row, skips the next
1788            * byte too for an even return address.
1789            HCHARF
1790  6D80 C28B                 mov r11,r10
1791  6D82 04C0                 clr r0
1792  6D84 04C1                 clr r1
1793  6D86 04C2                 clr r2
1794  6D88 04C3                 clr r3
1795  6D8A D83A                 movb *r10+,@>8301
1795  6D8C 8301  
1796            HCHARF2
1797  6D8E D83A                 movb *r10+,@>8303
1797  6D90 8303  
1798  6D92 D83A                 movb *r10+,@>8305
1798  6D94 8305  
1799  6D96 D83A                 movb *r10+,@>8307
1799  6D98 8307  
1800  6D9A 06A0                 bl @hchar
1800  6D9C 6DAA  
1801  6D9E D83A                 movb *r10+,@>8301
1801  6DA0 8301  
1802  6DA2 16F5                 jne HCHARF2
1803  6DA4 058A                 inc r10
1804  6DA6 045A                 b *r10
1805                    
1806            *HCHAR1 0,1,2 - single character hchar wrapper
1807  6DA8 C0C8 HCHAR1  MOV R8,R3       * LOADS 1 - LI R3,1
1808            * fall through into hchar
1809            
1810            *HCHAR  0,1,2,3 (ALL EXCEPT 2 and 3 ARE +1)
1811  6DAA C38B HCHAR   MOV R11,R14
1812  6DAC 06A0                 BL @HCHARADR
1812  6DAE 6D6C  
1813  6DB0 026C                 ORI R12,>4000
1813  6DB2 4000  
1814  6DB4 0695                 bl *r5
1815  6DB6 C302                 MOV R2,R12
1816  6DB8 06CC                 SWPB R12
1817  6DBA C343                 MOV R3,R13
1818  6DBC 1302                 JEQ HCHAROUT
1819  6DBE 06A0                 BL @VDPSET
1819  6DC0 6C88  
1820            HCHAROUT                
1821  6DC2 045E                 B *R14
1822            
1823            *GCHAR  0=ROW,1=COL, RETURN IN 2
1824  6DC4 C38B GCHAR   MOV R11,R14
1825  6DC6 06A0                 bl @hcharadr
1825  6DC8 6D6C  
1826  6DCA 0695                 bl *r5
1827  6DCC 04C2                 CLR R2
1828  6DCE D0A0                 MOVB @>8800,R2
1828  6DD0 8800  
1829  6DD2 06C2                 SWPB R2
1830  6DD4 045E                 B *R14
1831                            
1832            * scan - wrapped call to KSCAN
1833            * after this, KEY and JOYST just read the return variables
1834            SCAN
1835  6DD6 C38B                 mov r11,r14
1836  6DD8 D820                 movb @>8311,@>8374      * R8 LSB - mode 1 - scans keyboard and joystick
1836  6DDA 8311  
1836  6DDC 8374  
1837  6DDE 02E0                 lwpi >83e0              * GPLWS
1837  6DE0 83E0  
1838  6DE2 06A0                 bl @>000e               * scan
1838  6DE4 000E  
1839  6DE6 02E0                 lwpi >8300
1839  6DE8 8300  
1840  6DEA 045E                 b *r14
1841                            
1842            *KEY  Scan must be called first - RETURN 1=K
1843            KEY     
1844  6DEC 04C1                 clr r1
1845  6DEE D060                 movb @>8375,r1
1845  6DF0 8375  
1846  6DF2 06C1                 swpb r1
1847  6DF4 045B                 b *r11
1848                            
1849            * DSPRALL       DELETES ALL SPRITES
1850  6DF6 C38B DSPRALL MOV R11,R14
1851  6DF8 020C                 LI R12,>4300
1851  6DFA 4300  
1852  6DFC 0695                 bl *r5
1853  6DFE 06A0                 BL @VDPSETF
1853  6E00 6C80  
1854  6E02 E180                 byte >e1,128
1855            * and the automotion table
1856  6E04 020C                 LI R12,>4780
1856  6E06 4780  
1857  6E08 0695                 bl *r5
1858  6E0A 06A0                 BL @VDPSETF
1858  6E0C 6C80  
1859  6E0E 0080                 BYTE 0,128
1860  6E10 045E                 B *R14
1861            
1862            * VCHARF - fixed value vchar
1863            * the four values, as bytes, are at the return address
1864            * we have a lot of hchars...
1865            VCHARF
1866  6E12 C28B                 mov r11,r10
1867  6E14 04C0                 clr r0
1868  6E16 04C1                 clr r1
1869  6E18 04C2                 clr r2
1870  6E1A 04C3                 clr r3
1871  6E1C D83A                 movb *r10+,@>8301
1871  6E1E 8301  
1872            VCHARF2         
1873  6E20 D83A                 movb *r10+,@>8303
1873  6E22 8303  
1874  6E24 D83A                 movb *r10+,@>8305
1874  6E26 8305  
1875  6E28 D83A                 movb *r10+,@>8307
1875  6E2A 8307  
1876                            
1877            * inline vchar
1878  6E2C 06A0                 bl @hcharadr
1878  6E2E 6D6C  
1879  6E30 C343                 MOV R3,R13
1880  6E32 1309                 JEQ VCHAROUT
1881  6E34 026C                 ORI R12,>4000
1881  6E36 4000  
1882  6E38 06C2                 SWPB R2
1883  6E3A 0695 VCHAR1  bl *r5
1884  6E3C D502                 MOVB R2,*r4
1885  6E3E 022C                 AI R12,32
1885  6E40 0020  
1886  6E42 060D                 DEC R13
1887  6E44 16FA                 JNE VCHAR1
1888            *               SWPB R2                         * this one doesn't need to preserve r2
1889            VCHAROUT                
1890            
1891  6E46 D83A                 movb *r10+,@>8301
1891  6E48 8301  
1892  6E4A 16EA                 jne VCHARF2
1893  6E4C 058A                 inc r10
1894  6E4E 045A                 b *R10
1895            
1896            * get sprite vdp address from sprite r0 to r12
1897            SPRITEADR
1898  6E50 C300                 MOV R0,R12
1899  6E52 060C                 DEC R12
1900  6E54 0A2C                 SLA R12,2
1901  6E56 022C                 AI R12,>0300
1901  6E58 0300  
1902  6E5A 045B                 B *R11
1903                            
1904            * SPRITE 0=SPRITE+1, 1=ROW+2, 2=COL+1, 3=CHARACTER, 4=COLOR
1905            * passed as data bytes, not registers, color is NOT plus 1!
1906  6E5C C38B SPRITE  MOV R11,R14
1907  6E5E 04C0                 clr r0
1908  6E60 D83E                 movb *r14+,@>8301   * R1 LSB
1908  6E62 8301  
1909  6E64 06A0                 bl @SPRITEADR
1909  6E66 6E50  
1910  6E68 026C                 ORI R12,>4000
1910  6E6A 4000  
1911  6E6C 0695                 bl *r5
1912  6E6E D33E                 movb *r14+,r12
1913  6E70 022C                 ai r12,->0200
1913  6E72 FE00  
1914  6E74 D50C                 MOVB R12,*r4
1915  6E76 D33E                 movb *r14+,r12
1916  6E78 022C                 ai r12,->0100
1916  6E7A FF00  
1917  6E7C D50C                 MOVB R12,*r4
1918  6E7E D53E                 movb *r14+,*r4
1919  6E80 D53E                 movb *r14+,*r4
1920  6E82 058E                 inc r14
1921  6E84 045E                 B *R14
1922            
1923            * LOCATE 0=SPRITE+1, 1=ROW+2, 2=COL+1
1924  6E86 C38B LOCATE  MOV R11,R14
1925  6E88 06A0                 bl @spriteadr
1925  6E8A 6E50  
1926  6E8C 026C                 ORI R12,>4000
1926  6E8E 4000  
1927  6E90 0695                 bl *r5
1928  6E92 C301                 MOV R1,R12
1929  6E94 064C                 DECT R12                        * TOP LINE IS -1, NOT 1
1930  6E96 06CC                 SWPB R12
1931  6E98 D50C                 MOVB R12,*r4
1932  6E9A C302                 MOV R2,R12
1933  6E9C 060C                 DEC R12                         * LEFT COL IS 0, NOT 1
1934  6E9E 06CC                 SWPB R12
1935  6EA0 D50C                 MOVB R12,*r4
1936  6EA2 045E                 B *R14
1937            
1938            * POSITION 0=SPRITE+1, RETURN: 1=ROW+2, 2=COL+1
1939            POSITION        
1940  6EA4 C38B                 MOV R11,R14
1941  6EA6 06A0                 bl @spriteadr
1941  6EA8 6E50  
1942  6EAA 0695                 bl *r5
1943  6EAC 04C1                 CLR R1
1944  6EAE 04C2                 CLR R2
1945  6EB0 D060                 MOVB @>8800,R1
1945  6EB2 8800  
1946  6EB4 06C1                 SWPB R1
1947  6EB6 D0A0                 MOVB @>8800,R2
1947  6EB8 8800  
1948  6EBA 06C2                 SWPB R2
1949  6EBC 05C1                 INCT R1       * fix top line offset (-1 to 1)
1950  6EBE 0241                 ANDI R1,>00FF * mask it, it's supposed to wrap around
1950  6EC0 00FF  
1951  6EC2 0582                 INC R2        * fix left column (0 to 1) (256 is okay)
1952  6EC4 045E                 B *R14
1953            
1954            
1955            * set freq and call the duration you want (vol0)
1956            sound100
1957  6EC6 0200   li r0,6
1957  6EC8 0006  
1958  6ECA 1009   jmp sv0
1959            
1960            soundn100
1961  6ECC 0200   li r0,-6
1961  6ECE FFFA  
1962  6ED0 1006   jmp sv0
1963            
1964            sound300
1965  6ED2 0200   li r0,18
1965  6ED4 0012  
1966  6ED6 1003   jmp sv0
1967            
1968            * set freq and vol and come here (len 100)
1969            soundvol
1970  6ED8 0200   li r0,6
1970  6EDA 0006  
1971  6EDC 1001   jmp sound
1972            
1973            sv0
1974  6EDE 04C2   clr r2
1975              
1976            * SOUND  0 - DURATION (INCL. NEGATIVE), 1 - PITCH (INCL. NEGATIVE), 2 - VOLUME
1977            * Duration is in frames, volume is 0-15. Pitch remains in HZ
1978            * note: only one voice at a time, and tone or noise only
1979            * Note2: Duration calculation was wrong in TI MOTIF
1980  6EE0 C28B SOUND   mov r11,r10                     * save return for delay
1981  6EE2 C340                 MOV R0,R13
1982  6EE4 1101                 JLT ISNEG                       * NEGATIVE?
1983  6EE6 1002                 JMP SOUND1                      * IF NO, GO WAIT
1984            ISNEG
1985  6EE8 050D                 NEG R13                         * MAKE POSITIVE
1986  6EEA 1005                 JMP SOUND3                      * AND GO PLAY IT
1987            SOUND1  
1988  6EEC C320                 MOV @SNDDEL,R12
1988  6EEE 833A  
1989  6EF0 1302                 JEQ SOUND3
1990  6EF2 0696                 bl *r6                      * delay, sprites, etc
1991  6EF4 10FB                 JMP SOUND1
1992            SOUND3  
1993  6EF6 C80D                 MOV R13,@SNDDEL
1993  6EF8 833A  
1994  6EFA C381                 MOV R1,R14
1995  6EFC 111C                 JLT SOUND4                      * NEGATIVE, PLAY NOISE
1996  6EFE 020C                 LI R12,>0001            * POSITIVE, PLAY TONE
1996  6F00 0001  
1997  6F02 020D                 LI R13,>B4F5            * 111861
1997  6F04 B4F5  
1998  6F06 3F0E                 DIV R14,R12
1999  6F08 C34C                 MOV R12,R13
2000  6F0A 024C                 ANDI R12,>000F
2000  6F0C 000F  
2001  6F0E 026C                 ORI R12,>0080
2001  6F10 0080  
2002  6F12 06CC                 SWPB R12
2003  6F14 D80C                 MOVB R12,@>8400
2003  6F16 8400  
2004  6F18 094D                 SRL R13,4
2005  6F1A 06CD                 SWPB R13
2006  6F1C D80D                 MOVB R13,@>8400
2006  6F1E 8400  
2007  6F20 C302                 MOV R2,R12
2008  6F22 026C                 ORI R12,>0090
2008  6F24 0090  
2009  6F26 06CC                 SWPB R12
2010  6F28 D80C                 MOVB R12,@>8400
2010  6F2A 8400  
2011  6F2C 020C                 LI R12,>FF00
2011  6F2E FF00  
2012  6F30 D80C                 MOVB R12,@>8400
2012  6F32 8400  
2013  6F34 1010                 JMP SOUND5
2014  6F36 054E SOUND4  INV R14
2015            *               ANDI R14,>000F
2016  6F38 026E                 ORI R14,>00E0
2016  6F3A 00E0  
2017  6F3C 06CE                 SWPB R14
2018  6F3E D80E                 MOVB R14,@>8400         * PLAY NOISE
2018  6F40 8400  
2019  6F42 C302                 MOV R2,R12
2020  6F44 026C                 ORI R12,>00F0
2020  6F46 00F0  
2021  6F48 06CC                 SWPB R12
2022  6F4A D80C                 MOVB R12,@>8400
2022  6F4C 8400  
2023  6F4E 020C                 LI R12,>9F00
2023  6F50 9F00  
2024  6F52 D80C                 MOVB R12,@>8400
2024  6F54 8400  
2025  6F56 045A SOUND5  B *R10  
2026            
2027            * PATTERN 0 = SPRITE+1, 1=CHARACTER CODE
2028  6F58 C38B PATTERN MOV R11,R14
2029  6F5A C300                 MOV R0,R12
2030  6F5C 060C                 DEC R12
2031  6F5E 0A2C                 SLA R12,2
2032  6F60 022C                 AI R12,>0302
2032  6F62 0302  
2033  6F64 026C                 ORI R12,>4000
2033  6F66 4000  
2034  6F68 0695                 bl *r5
2035  6F6A 06C1                 SWPB R1
2036  6F6C D501                 MOVB R1,*r4
2037  6F6E 06C1                 SWPB R1
2038  6F70 045E                 B *R14
2039                            
2040            * COINC - (only ALL) return non-zero in r0 if set - uses cached copy, ints must run!
2041            COINC 
2042            * we do the frame interrupt inline here - this is called every game frame!
2043            * we use R0 for scratch because we return r0 anyway
2044  6F72 04E0                 clr @>83d6
2044  6F74 83D6  
2045            INTWAIT         
2046  6F76 0300                 limi 2
2046  6F78 0002  
2047  6F7A 0300                 limi 0
2047  6F7C 0000  
2048  6F7E C020                 mov @>83d6,r0
2048  6F80 83D6  
2049            *               ci r0,0                 * int increments by two when it runs, so this is our throttle
2050            *               jl intwait
2051  6F82 13F9                 jeq intwait
2052                            
2053            * handle sound timeout
2054  6F84 C020                 mov @snddel,r0
2054  6F86 833A  
2055  6F88 130E                 jeq intw2
2056                            
2057  6F8A 0220                 ai r0,-6                        * number of frames above
2057  6F8C FFFA  
2058  6F8E C800                 mov r0,@snddel
2058  6F90 833A  
2059  6F92 1509                 jgt intw2
2060  6F94 04E0                 clr @snddel
2060  6F96 833A  
2061  6F98 0200         LI R0,>9FFF             * mute all sound (we only use 2 channels)
2061  6F9A 9FFF  
2062  6F9C D800                 MOVB R0,@>8400
2062  6F9E 8400  
2063  6FA0 06C0                 SWPB R0
2064  6FA2 D800                 MOVB R0,@>8400
2064  6FA4 8400  
2065            intw2
2066            
2067            * this is the actual coinc now
2068  6FA6 04C0                 CLR r0
2069  6FA8 D020                 movb @>837b,r0
2069  6FAA 837B  
2070            * todo: dynamic cheat?          
2071            *               andi r0,>2000
2072            * THIS LINE IS CHEATING
2073  6FAC 0240                 andi r0,>0000
2073  6FAE 0000  
2074  6FB0 045B                 B *R11
2075            
2076            * CDELAY - r0 number of times to call COINC
2077            CDELAY
2078  6FB2 C38B                 mov r11,r14
2079  6FB4 C300                 mov r0,r12
2080            CDELAY1
2081  6FB6 0696                 bl *r6
2082  6FB8 060C                 dec r12
2083  6FBA 16FD                 jne cdelay1
2084  6FBC 045E                 b *R14
2085            
2086            * MOTION 0=sprite+1, 1=row speed, 2=column speed
2087            MOTION
2088  6FBE C38B                 MOV R11,R14
2089  6FC0 06A0                 bl @spriteadr
2089  6FC2 6E50  
2090  6FC4 022C                 AI R12,>4480
2090  6FC6 4480  
2091  6FC8 0695                 bl *r5
2092  6FCA 06C1                 swpb r1
2093  6FCC D501                 movb r1,*r4
2094  6FCE 06C1                 swpb r1
2095  6FD0 06C2                 swpb r2
2096  6FD2 D502                 movb r2,*r4
2097  6FD4 06C2                 swpb r2
2098  6FD6 04CC                 clr r12
2099  6FD8 D50C                 movb r12,*r4
2100  6FDA D50C                 movb r12,*r4
2101  6FDC 045E                 B *R14
2102            
2103            *delspr - r0 = sprite+1
2104            DELSPR
2105  6FDE C38B                 MOV R11,R14
2106  6FE0 C300                 MOV R0,R12
2107  6FE2 060C                 DEC R12
2108  6FE4 0A2C                 SLA R12,2
2109  6FE6 022C                 AI R12,>4300
2109  6FE8 4300  
2110  6FEA 0695                 bl *r5
2111  6FEC 020D                 li r13,>E100                    * sprite automotion doesn't allow values from c1-e0
2111  6FEE E100  
2112  6FF0 D50D                 movb r13,*r4
2113  6FF2 022C                 ai r12,>0480
2113  6FF4 0480  
2114  6FF6 0695                 bl *r5
2115  6FF8 04CD                 clr r13
2116  6FFA D50D                 movb r13,*r4
2117  6FFC D50D                 movb r13,*r4
2118  6FFE D50D                 movb r13,*r4
2119  7000 D50D                 movb r13,*r4
2120  7002 045E                 b *r14
2121            
2122            waitnewkey
2123  7004 C28B                 mov r11,r10
2124            waitA           
2125  7006 06A0                 bl @scan
2125  7008 6DD6  
2126  700A 06A0                 bl @key
2126  700C 6DEC  
2127  700E 0281                 ci r1,18
2127  7010 0012  
2128  7012 13F9                 jeq waitA
2129            waitB   
2130  7014 0696                 bl *r6          * delays and sound processing!
2131  7016 06A0                 bl @scan
2131  7018 6DD6  
2132  701A 06A0                 bl @key
2132  701C 6DEC  
2133  701E 0281                 ci r1,18
2133  7020 0012  
2134  7022 16F8                 jne waitB
2135                            
2136  7024 045A                 B *r10
2137            
2138            * converts sprite pixel coordinates to chars
2139            * RO returns in r0, CO returns in r1 (each /8+1)                
2140            pix2char
2141  7026 C020                 mov @ro,r0
2141  7028 8330  
2142  702A 0930                 srl r0,3
2143  702C 0580                 inc r0
2144  702E C060                 mov @co,r1
2144  7030 8332  
2145  7032 0931                 srl r1,3
2146  7034 0581                 inc r1
2147  7036 045B                 B *r11
2148                            
2149  7038 0000                 END
2149            


 Assembly Complete - Errors: 0,  Warnings: 0


 ------ Symbol Listing ------

 A      ABS:832A A
 AS     ABS:8326 AS
 B      ABS:832C B
 BONUS  ABS:6042 BONUS
 CDAT   ABS:68B8 CDAT
 CDELAY ABS:6FB2 CDELAY
 CDELAY ABS:6FB6 CDELAY1
 CHAR   ABS:6D4A CHAR
 CHAR1  ABS:6D58 CHAR1
 CHARDA ABS:6056 CHARDAT1
 CHARDA ABS:60EE CHARDAT2
 CHARDA ABS:60FE CHARDAT3
 CLEAR  ABS:6C90 CLEAR
 CO     ABS:8332 co
 COINC  ABS:6F72 COINC
 CS     ABS:8336 cs
 DELSPR ABS:6FDE DELSPR
 DISNUM ABS:6CD2 DISNUM
 DISPAD ABS:6CA6 DISPADR
 DISPLA ABS:6CBE DISPLAY
 DRAW   ABS:68BC DRAW
 DSEXIT ABS:6CD0 DSEXIT
 DSLP1  ABS:6CC8 DSLP1
 DSPRAL ABS:6DF6 DSPRALL
 ENDVAR ABS:833C ENDVARS
 FFBYTE ABS:6055 FFBYTE
 GAMEOV ABS:6038 GAMEOVER
 GCHAR  ABS:6DC4 GCHAR
 GOGAME ABS:6106 GOGAME
 HCHAR  ABS:6DAA HCHAR
 HCHAR1 ABS:6DA8 HCHAR1
 HCHARA ABS:6D6C HCHARADR
 HCHARF ABS:6D80 HCHARF
 HCHARF ABS:6D8E HCHARF2
 HCHARO ABS:6DC2 HCHAROUT
 HELPHE ABS:6050 HELPHELP
 HEROX  ABS:6016 HEROX
 IJ     ABS:8338 ij
 INITL1 ABS:6132 INITL1
 INTW2  ABS:6FA6 intw2
 INTWAI ABS:6F76 INTWAIT
 ISNEG  ABS:6EE8 ISNEG
 JTAB2  ABS:6A38 JTAB2
 JTABLE ABS:68D2 JTABLE
 JUMP2  ABS:625A jump2
 JUMP2B ABS:626C jump2b
 JUMP3  ABS:6270 jump3
 JUMP4  ABS:6284 jump4
 JUMP5  ABS:62B0 jump5
 JUMP6  ABS:62BA jump6
 KEY    ABS:6DEC KEY
 L100   ABS:61D6 l100
 L1000  ABS:648E l1000
 L1015B ABS:64A0 l1015b
 L10160 ABS:68DC l10160
 L10300 ABS:6916 l10300
 L10400 ABS:6948 l10400
 L10500 ABS:698A l10500
 L10600 ABS:69E8 l10600
 L10720 ABS:6A42 l10720
 L10720 ABS:6A70 l10720b
 L10800 ABS:6ABC l10800
 L10800 ABS:6AEA l10800b
 L10900 ABS:6B26 l10900
 L10900 ABS:6B54 l10900b
 L11000 ABS:6B98 l11000
 L12000 ABS:6BF8 l12000
 L150   ABS:61EA l150
 L170   ABS:6218 l170
 L190   ABS:6232 l190
 L20    ABS:61A2 l20
 L2000  ABS:64A4 l2000
 L2005B ABS:64AC l2005b
 L2005C ABS:64C6 l2005c
 L2010B ABS:64CE l2010b
 L2010C ABS:64EC l2010c
 L2030  ABS:64FC l2030
 L210   ABS:6242 l210
 L210B  ABS:62BE l210b
 L212   ABS:62FC l212
 L225   ABS:6322 l225
 L228B  ABS:6332 l228b
 L228C  ABS:6330 l228c
 L230   ABS:633A l230
 L260B  ABS:635C l260b
 L260C  ABS:635A l260c
 L270B  ABS:6380 l270b
 L300   ABS:6384 l300
 L3000  ABS:653A l3000
 L3000B ABS:6542 l3000b
 L3000C ABS:6560 l3000c
 L300B  ABS:6392 l300b
 L3020B ABS:656C l3020b
 L3040  ABS:658A l3040
 L3040B ABS:6590 l3040b
 L400   ABS:63AA l400
 L4000  ABS:6594 l4000
 L4000B ABS:659C l4000b
 L4000C ABS:65BA l4000c
 L4010B ABS:65BE l4010b
 L4010C ABS:65DE l4010c
 L4020B ABS:65EA l4020b
 L4020C ABS:661A l4020c
 L4070  ABS:665C l4070
 L410B  ABS:6402 l410b
 L4180B ABS:6704 l4180b
 L4180C ABS:6718 l4180c
 L4190B ABS:671C l4190b
 L4190C ABS:674C l4190c
 L4210B ABS:6758 l4210b
 L4210C ABS:6778 l4210c
 L4230B ABS:6784 l4230b
 L4230C ABS:67A6 l4230c
 L4260B ABS:67BC l4260b
 L430   ABS:6428 l430
 L430B  ABS:6448 l430b
 L4320B ABS:67F4 l4320b
 L435   ABS:6448 l435
 L4390B ABS:682C l4390b
 L440   ABS:644C l440
 L4400B ABS:688C l4400b
 L440B  ABS:645C l440b
 L4410B ABS:6890 l4410b
 L4420  ABS:68AE l4420
 L4420B ABS:68B4 l4420b
 L450B  ABS:6478 l450b
 L450C  ABS:6480 l450c
 L460B  ABS:648A l460b
 LE     ABS:8320 LE
 LOCATE ABS:6E86 LOCATE
 MOTION ABS:6FBE MOTION
 NM     ABS:8322 NM
 NSKP1  ABS:6D02 NSKP1
 NSKP2  ABS:6D1C NSKP2
 NSKP3  ABS:6D36 NSKP3
 NW     ABS:8328 NW
 PATTER ABS:6F58 PATTERN
 PIX2CH ABS:7026 pix2char
 POSITI ABS:6EA4 POSITION
 PRESSF ABS:601C PRESSFIRE
 PROG1  ABS:600C PROG1
 QW     ABS:832E qw
 R0     ABS:0000 R0
 R1     ABS:0001 R1
 R10    ABS:000A R10
 R11    ABS:000B R11
 R12    ABS:000C R12
 R13    ABS:000D R13
 R14    ABS:000E R14
 R15    ABS:000F R15
 R2     ABS:0002 R2
 R3     ABS:0003 R3
 R4     ABS:0004 R4
 R5     ABS:0005 R5
 R6     ABS:0006 R6
 R7     ABS:0007 R7
 R8     ABS:0008 R8
 R9     ABS:0009 R9
 RO     ABS:8330 ro
 RS     ABS:8334 rs
 SC     ABS:8324 SC
 SCAN   ABS:6DD6 SCAN
 SDAT1  ABS:6A8C SDAT1
 SDAT2  ABS:6B06 SDAT2
 SDAT3  ABS:6B70 SDAT3
 SDAT4  ABS:6BDC SDAT4
 SDAT5  ABS:6C46 SDAT5
 SHAPES ABS:6A26 SHAPES
 SKIP01 ABS:6CF2 SKIP01
 SKIP02 ABS:6D0C SKIP02
 SKIP03 ABS:6D26 SKIP03
 SKIP04 ABS:6D40 SKIP04
 SNDDEL ABS:833A SNDDEL
 SOUND  ABS:6EE0 SOUND
 SOUND1 ABS:6EEC SOUND1
 SOUND1 ABS:6EC6 sound100
 SOUND3 ABS:6EF6 SOUND3
 SOUND3 ABS:6ED2 sound300
 SOUND4 ABS:6F36 SOUND4
 SOUND5 ABS:6F56 SOUND5
 SOUNDN ABS:6ECC soundn100
 SOUNDV ABS:6ED8 soundvol
 SPRITE ABS:6E5C SPRITE
 SPRITE ABS:6E50 SPRITEADR
 SV0    ABS:6EDE sv0
 VCHAR1 ABS:6E3A VCHAR1
 VCHARF ABS:6E12 VCHARF
 VCHARF ABS:6E20 VCHARF2
 VCHARO ABS:6E46 VCHAROUT
 VDPCPY ABS:6D64 VDPCPY
 VDPSET ABS:6C88 VDPSET
 VDPSET ABS:6C80 VDPSETF
 VDPTAB ABS:6C6A VDPTAB
 WAITA  ABS:7006 waitA
 WAITB  ABS:7014 waitB
 WAITNE ABS:7004 waitnewkey
 WRADR  ABS:6C72 WRADR
