************************
* HeroX - by Tursi     *
* Ported by Tursi      *
************************

* VDP Usage:
*
* 0000	02FF
* 0300	037F	SAL  (reg 5, 00-7F, scale >0080, value 06)
* 0380	077F
* 0780	07ff	Sprite motion table (interrupt driven, not movable)
* 0800	0FFF	PDT (reg 4, 0-7, scale >0800, value 01) & SPT (reg 6, 0-7, scale >0800, value 01)
* 1000	101F	CT (reg 3, 00-ff, scale >0040, value 40)
* 1020  1FFF    
* 2000  24FF    SIT (reg 2, 0-F, scale >0400, value 08 (256 bytes extra padding, thus not 768 bytes))
* 2500  26FF    sound lists
* 2700  3FFF
*
* Register usage
* R0 - Scratch, argument passing
* R1 - Scratch, argument passing
* R2 - Scratch, argument passing
* R3 - Scratch, argument passing
* R4 - >8c00 (vdp write data)		26 hits
* R5 - hcharf function address		12 hits
* R6 - coinc function address		12 hits
* R7 - pattern function address		12 hits
* R8 - Always 1 - don't change it (optimization) (18 hits)
* R9 - motion function address		 8 hits
* R10- Subroutine scratch
* R11- Return address for BL, subroutine usage
* R12- Subroutine scratch
* R13- Subroutine scratch
* R14- Subroutine scratch
* R15- Subroutine scratch (SUB return address)
*
* System Free Scratchpad RAM:
* 00 - 1f - Workspace
* 20 - 49 - available for variables (check with listing)
* 4A - 6D - stack area - probably free
* 6E - 6F - free outside of floating point
* 70 - 7F - GPL status block
* 80 - BF - GPL Stack - used as second workspace during COINC work
* C0 - DF - Interrupt workspace
* E0 - FF - GPLWS

* hcharf 	- 12 hits
* cdelay 	- 10 hits

* animmove 	- 7 hits
* vcharf 	- 7 hits
* display 	- 6 hits
* position 	- 6 hits
* animframe - 5 hits
* disnum 	- 5 hits
* spriteadr - 5 hits
* wradrf	- 5 hits
* gchar 	- 4 hits
* waitsound - 4 hits







* Variables in RAM
*
	AORG >8320
	
* VARIABLES
LE	bss 2	* level
NM	bss 2	* number men
SC	bss 2	* score
NW	bss 2	* number wafers left
A	bss 2	* index loop
B	bss 2	* index loop
ro	bss 2	* row (usually player, but sprite is authoritative)
co  bss 2	* column (same)
rs  bss 2	* row speed (used for jumping)
cs  bss 2   * column speed (used for jumping)
ij  bss 2   * is jumping (wasteful, but we can afford it)
save bss 2	* extra return address
bonus bss 2	* bonus timer

* SHARED VARIABLES
ENDVARS BSS 2			* just dummy so the listing file has an address (do not use)

* Cartridge Header (if cart, not used for MM)
		AORG >6000

* PROGRAMS ARE LISTED IN REVERSE ORDER
		
		DATA >AA01,>0200,>0000,PROG1,>0000,>0000
PROG1	DATA >0000,GOGAME,>0548
		TEXT 'EROX'
		EVEN

* start in MiniMem RAM range
		DEF GOGAME
* todo: enable when it fits in 4k ;)
*		AORG >7000

HEROX	TEXT 'HERO'
		BYTE >80
NOISESND
		BYTE >E5
		EVEN
		
PRESSFIRE
		TEXT 'PRESS FIRE BUTTON TO PLAY'
		BYTE >80
		EVEN
		
GAMEOVER
		TEXT 'GAME OVER'
		BYTE >80
		EVEN

BONUSTXT
		TEXT 'BONUS= 100 X'
		BYTE >80
		EVEN
		
JUSTBONUS
		TEXT 'BONUS'
		BYTE >80
		EVEN
		
HELPHELP
		TEXT 'HELP'
		BYTE >80
FFBYTE
		BYTE >FF
		EVEN
		
* contains noise channel volume for the footstep frames
runsnd
		data >f8ff,>ffff

* tried bit reversal to calculate mirrored patterns, but it only
* saved 4 bytes -- the data to support it was then larger than
* the raw patterns themselves.
CHARDAT1
		data >0000,>023E,>FB39,>0000	*  96	bird right
		data >0000,>3AFE,>3B11,>0000	*  97
		data >0000,>3AFE,>3B01,>0000	*  98
		data >0000,>103A,>FE3B,>0100	*  99
		
		data >0000,>5C7F,>DC80,>0000	* 100	bird left
		data >0000,>085C,>7FDC,>8000	* 101
		data >0000,>407C,>DF9C,>0000	* 102
		data >0000,>5C7F,>DC88,>0000	* 103

		DATA >0000,>007E,>FFFF,>FFFF	* 104	hole
		DATA >FF3C,>42A5,>A542,>3CFF	* 105	girder
		data >4428,>1010,>7C92,>3810	* 106	player falling
		DATA >183C,>382E,>1C3E,>1400	* 107	girl
		DATA >1818,>3C18,>08F8,>0814	* 108	boss 1
		DATA >3030,>7830,>9070,>1028	* 109	boss 2
		data >1818,>3C18,>08F8,>0814	* 110	boss 3
		DATA >3030,>7830,>1070,>9028	* 111	boss 4
		data >0000,>3E22,>2A22,>3E00	* 112	crystal
		data >2418,>187E,>99BD,>1818	* 113	boss die
		data >66FF,>FFFF,>7E3C,>1800	* 114	heart

* ladder and player animation		
CHARDAT3
		data >7E42,>4242,>7E42,>4242	* 128

		data >0c0c,>1818,>1c18,>3808	* right  129
		data >0c0c,>1818,>1818,>1810	* 130
		data >0c0c,>1838,>3c1c,>2420	* 131
		data >0c0c,>385e,>1824,>4404	* 132 (legs out)
		
		data >3030,>1818,>3818,>1c10	* left  133
		data >3030,>1818,>1818,>1808	* 134
		data >3030,>181c,>3c38,>2404	* 135
		data >3030,>1c7a,>1824,>2220	* 136
		
		data >2038,>381C,>1C38,>2404	* climbing ladder 137
		data >0038,>383E,>1838,>2404	* 138
		data >041C,>1C38,>381C,>2420	* 139
		data >001C,>1C7C,>181C,>2420	* 140
		
		data >0C0C,>385E,>1826,>4000	* 141 jump right
		data >3030,>1C7A,>1864,>0200	* 142 jump left
		
		DATA >3030,>181C,>1828,>2828	* 143 player pre-punch
		DATA >6060,>30F0,>3028,>2828	* 144 player punch

* parts		
		data >FFFE,>FFFE,>FFFE,>FFFE	* 145	machine
		data >FFFE,>FCF1,>F1FC,>FEFF	* 146	broken machine
		
* worm enemy
		data >0000,>0000,>0000,>1866	* 147
		data >0000,>0000,>0018,>2424	* 148
		data >0000,>0000,>0000,>1866	* 149
		data >0000,>0000,>0000,>007e	* 150
		
* sound lists
firstsnd
jumpsnd
* jump sound was from mario bros (39 bytes)
* delays would normally be 1, but I skipped every other frame
* to reduce the memory usage
		byte 3,>86,>2A,>93,2
		byte 2,>8A,>20,2
		byte 2,>82,>19,2
		byte 2,>84,>13,2
		byte 2,>8C,>0E,2
		byte 3,>85,>0B,>95,2
		byte 3,>8A,>08,>99,2
		byte 3,>88,>06,>9C,2
		byte 1,>9F,0
		
wafersnd
		data >038b,>0C90,>0601,>9F00
		
fallsound
		data >0380,>0790,>0102,>8f07
		data >0102,>8109,>0102,>8f0a
		data >0102,>8b0c,>0102,>8e0f
		data >0102,>8215,>0102,>8c1f
		data >0102,>883f,>0101,>9f00
		
gameoversnd
		byte 6,>90,>b0
		byte 136,3,140,1,2
		byte 4,140,3,141,1,2
		byte 4,143,3,143,1,2
		byte 4,131,4,129,2,2
		byte 4,136,4,132,2,2
		byte 4,142,4,134,2,2
		byte 4,132,5,138,2,2
		byte 4,140,5,141,2,2
		byte 4,133,6,130,3,2
		byte 4,128,7,135,3,2
		byte 4,142,7,142,3,2
		byte 4,143,8,134,4,2
		byte 4,135,10,130,5,2
		byte 4,136,12,129,6,2
		byte 4,137,15,136,7,2
		byte 4,137,20,141,9,2
		byte 4,134,30,131,14,2
		byte 4,132,58,139,25,2
		byte 2,>9f,>bf,60
		byte 1,>9f,0
		
gamewin
		byte 3,>90
		byte 139,12,1
		byte 2,137,10,1
		byte 2,129,9,1
		byte 2,143,7,1
		byte 2,129,7,1
		byte 1,>9f,0

punchsnd
		data >02e5,>f406,>01ff,>0000
		
happysnd
		byte 3,>90
		byte 131,21,18
		byte 2,131,18,18
		byte 2,128,20,18
		byte 2,132,17,18
		byte 2,142,15,18
		byte 2,130,14,18
		byte 2,131,15,18
		byte 2,137,13,18
		byte 2,139,12,18
		byte 2,137,11,18
		byte 2,132,12,18
		byte 2,131,11,18
		byte 2,129,9,18
		byte 2,133,10,18
		byte 2,139,12,18	
		byte 1,>9f,0

tallysnd
		data >038f,>1190,>0201,>9f00

* label for the end of sound data
endsound
			
GOGAME	
		LIMI 0				* disable interrupts
		LWPI >8300			* set correct workspace
		LI R8,1				* we reserve R8 to always be the value '1' to save some memory
		li r4,>8C00			* VDPWD
		LI R5,hcharf		* R5 for hcharf
		LI R6,coinc			* r6 for coinc
		LI R7,pattern1		* r7 for pattern1 (pattern for player1)
		li r9,motion		* r9 for motion
		clr @sc

* inline initvdp
* Set GR0 mode similar to XB
		LI R12,>8000    * reg 0 gets >00, so this is correct
		LI R13,VDPTAB
INITL1
		bl @wradrf
		AI R12,>0100
		MOVB *R13+,@>8319	* R12 LSB - that allows us to check for 00 here
		JNE INITL1
		
		LI R12,>E11F	* 16k, screen on, ints on, magnify 1 (differs from XB) & automotion limit
		MOVB R12,@>83d4 * put VDP R1 at the KSCAN reload
		SWPB R12
		LI R0,>0F00		* 15 sprites moving
		MOVB R0,@>837A	* automotion limit

* we won't call CLEAR, user can do that, but we do
* need to wipe the sprite table
		BL @VDPSETF
		data >4300
		BYTE >D0,128
* and the automotion table
		BL @VDPSETF
		data >4780
		BYTE 0,128
* and set the color table to all black on trans
		BL @VDPSETF
		data >5000
		byte >10,32
* copy over the sound lists
		bl @vdpcpy
		data >6500,firstsnd,endsound-firstsnd

*1 CALL SCREEN(15)		* in the VDP init

*10 CALL INIT		- not the XB init, my own sub!
* inline init	
*10005 CALL COLOR(10,7,1,11,14,1,12,2,1,13,11,1)
	bl @vdpcpy
	data >500d,CDAT,4
	
*10010 RESTORE		* oh, goodie... data
*10020 FOR A=96 TO 114
*10030 READ A$ :: CALL CHAR(A,A$)
*10040 NEXT A
	bl @char
	byte 96,152
	data chardat1
	
*10050 CALL CHAR(120,"FFFEFFFEFFFEFFFEFFFEFCF1F1FCFEFF")
* merged into chardat3, new chars
	
*10060 CALL CHAR(128,"7E4242427E424242")
	bl @char
	byte 128,184
	data chardat3

*10120 SUBEND

*20 CALL CLEAR
l20
		BL @CLEAR
		
* run sound init
		movb @ffbyte,@>8400	* no run sound
		movb @NOISESND,@>8400 * pfft sound

*25 CALL DELSPRITE(ALL)
*		BL @DSPRALL		* done in clear

*30 CALL MAGNIFY(2)
* already done in the VDP Init

*40 CALL HCHAR(11,14,105,6)
*50 CALL HCHAR(13,14,105,6)

		bl *r5
		byte 11,14,105,6
		byte 13,14,105,6
		byte 0,0

*60 CALL VCHAR(11,14,105,3)
*70 CALL VCHAR(11,19,105,3)

		bl @vcharf
		byte 11,14,105,3
		byte 11,19,105,3
		byte 0,0

*80 DISPLAY AT(12,13)SIZE(4):"HERO"
		bl @display
		byte 12,13
		data herox

* score on title page
		mov @sc,r0
		jeq l90
		bl @disnum

*90 DISPLAY AT(23,1):"PRESS FIRE BUTTON TO PLAY."
l90
		bl @display
		byte 22,1
		data pressfire

*100 CALL KEY(1,K,S)
*110 IF K=18 THEN C=1 :: GOTO 140 (not doing c)
*130 IF K<>18 THEN 100
l100
		bl @waitnewkey

*140 LE=1 :: NM=3 :: SC=0
	mov r8,@le
	li r0,3
	mov r0,@nm
	clr @sc

*150 CALL DELSPRITE(ALL)
l150
*	BL @DSPRALL  * done in clear

*155 AS=0 * no longer used - bl animframe instead

*157 NW=4
	li r0,4
	mov r0,@nw

*160 CALL DRAW(LE) - this is the only call
	bl @draw

*162 CALL HCHAR(23,4,97,NM)
	bl @showlives

*165 DISPLAY AT(24,1):SC
	bl @disnum

* init the bonus (this is skipped if you die)
	li r0,1800		* 30s per level
	li r1,6			* subtract level
	s @le,r1
	mpy r1,r0		* r1 now has the value we care about (32-bit result)
	mov r1,@bonus

*170 CALL SHAPES(LE) - this is the only call
l170
	bl @shapes

*180 CALL SPRITE(#1,96,16,152,32)
	bl @sprite
	byte 1,153,32,132,15,0		* player moved to 129-132

	clr @rs
	clr @cs
	clr @ij
	
	bl @display
	byte 23,25
	data justbonus
	bl @disbonus

*190 CALL KEY(C,K,S) :: IF K<>18 THEN 190 - ignoring c
* note: jump/move is really different now
l190
	bl @waitnewkey

*200 CALL COLOR(#1,2)
* Inline SPcolor
	bl @wradr
	data >4303
	MOVB @>8311,*r4    * R8 LSB for color 1

*210 CALL JOYST(C,X,Y)
l210
* count down the bonus - die if it wraps
	mov @bonus,r0
	jeq bonusok			* if bonus is zero, then ignore it
	
	dec @bonus
	jne bonusok
	b @l2000			* die if bonus expired
bonusok
	bl @disbonus
	
* run sound off by default	
	movb @ffbyte,@>8400
	
* new movement code
	mov @ij,r0
	jeq l210b
	
* handle ongoing jump (or fall)
	inc @rs
	mov @rs,r3
	ci r3,24    	* max fall speed
	jlt jump2
	b @l2000		* die if fall too far
jump2
	mov r8,r0
	bl @position
	a @cs,r2
	ci r2,4
	jl jump2b
	ci r2,249
	jl jump3
jump2b
	s @cs,r2		* clip to screen edges
jump3
	sra r3,2		* divide jump speed
	a r3,r1			* add to position
	ci r1,187
	jlt jump4
	ci r1,220   	* don't die for wraparound
	jgt jump4   
	b @l2000		* die if fall off bottom
jump4
	mov r1,@ro
	mov r2,@co
	bl @locate		* move sprite into place

	mov @rs,r0
	jlt jump5		* skip if moving up
	bl @pix2char
	inct r0
	bl @gchar
	ci r2,32
	jeq jump5
	ci r2,112
	jeq jump5
	clr @ij			* landed
	bl @snaprow	* snap row

	li r1,136
	mov @cs,r0
	jlt jump4b
	ai r1,-4
jump4b
	bl *r7			* pattern1
	
jump5
	bl *r6			* coinc
	mov r0,r0
	jeq jump6
	b @l2000
jump6
	b @l210			* loop around

* normal movement
l210b
	bl @scan
* inline joyst
	movb @>8377,r1
	sra r1,10       * sign extend, /2!
	mov r1,@cs
	movb @>8376,r1
	sra r1,10       * sign extend, /2!
	mov r1,@rs

* don't have RND, so using animframe
*211 IF LE=5 THEN CALL PATTERN(#2,108+RND)
* 2 is never used anywhere else, so can always animate
	bl @animframe
	ai r1,107		* animframe = 1-4
	li r0,2
	bl @pattern

*212 IF X=0 AND Y=0 THEN GOTO 300
* omitted for ROM space

* moved code - do y first to make ladders safer
*230 if y=0 then 214
	mov @rs,r0
	jeq l214

*250 CALL POSITION(#1,RO,CO)
l250
	mov r8,r0
	bl @positionraw

*260 CALL GCHAR(RO/8+1-2*(Y=-4),CO/8+1,QW)
	bl @pix2char
	mov @rs,r2
	jlt l260c
	jmp l260b
l260c
	inct r0
l260b
	bl @gchar

*270 IF QW=128 THEN CALL PATTERN(#1,100) :: CALL POSITION(#1,RO,CO) :: RO=RO-Y*2 :: RO=RO-(RO=0) :: CALL LOCATE(#1,RO,CO)
	ci r2,128
	jne l214		* allow x if y is illegal

	bl @animframe
	ai r1,136
	bl *r7			* pattern1
	
	mov r8,r0
	bl @position

	s @rs,r1
	
*	jne l270b  * this was just an XB limit workaround - 0 is illegal there
*	inc r1
*l270b
	
	mov r1,@ro
	bl @snapcol		* this will call locate
	
	jmp l300		* don't allow x movement

*214 if X=0 then 300
l214
	mov @cs,r0
	jeq l300

*217 CALL POSITION(#1,RO,CO)
	mov r8,r0
	bl @positionraw

*220 CO=CO+X*2 :: if CO<1 or CO>255 then 225
	mov @cs,r3
	a r3,r2		  * SLA and a 16-bit value don't work for negative
	ci r2,4
	jl l225
	ci r2,248
	jh l225		  * handles > 248 or negative (255 was uneven)

*221 CALL LOCATE(#1,RO,CO)
	mov r2,@co
	bl @snaprow		* this will call locate

*225 AS=AS=0 * no longer used
l225

*228 CALL PATTERN(#1,96-2*(X=-4)-AS)
* player moved to 129-132, plus more frames
* 0 = 129 or 134 (maybe just 129 for convenience)
* animframe needs to return 1-4
	bl @animframe
	movb @runsnd-1(r1),@>8400
	ai r1,132
*	mov @x,r0	* @X is still in r3
    mov r3,r3
    jlt l228b
l228c
	ai r1,-4
l228b
	bl *r7		* pattern1

*300 CALL KEY(C,K,S) :: IF K<>18 THEN 400
l300
	bl @key      * scan was already done above
*	ci r1,18     * done in key
	jeq l300b
	b @l400
l300b

*310 REM  JUMP*********
* new code - we just set up the variables
	seto @ij
	li r0,-10
	mov r0,@rs

	li r1,142
	mov @cs,r0
	jlt l310b
	dec r1
l310b	
	bl *r7		* pattern1
	
*330 CALL SOUND(100,-3,15)
	bl @playsound
	data jumpsnd-firstsnd+>2500

* check for wafer (thus +2, not +3)
*400 CALL POSITION(#1,RO,CO) :: RO=RO/8+2 :: CO=CO/8+1
* if we got the wafer, do all this
*410 CALL GCHAR(RO,CO,QW) :: IF QW=112 THEN CALL HCHAR(RO,CO,32) :: CALL SOUND(100,550,0) :: NW=NW-1 :: SC=SC+50 :: DISPLAY AT(24,1):SC
l400
	mov r8,r0
	bl @positionraw
	bl @pix2char
	inc r0
	mov r0,@ro		* NOTE! For this block ro,co are CHARACTER positions
	mov r1,@co

	bl @gchar
	ci r2,112
	jne l410b
	
	mov @ro,r0		* erase wafer
	mov @co,r1
	li r2,32
	bl @hchar1
	
	bl @playsound
	data wafersnd-firstsnd+>2500
	
	dec @nw			* count collected wafers
	
	li r0,50		* add to score
	a r0,@sc
	
	bl @disnum		* display new score
l410b

* check for ladder appearance (easier to cheat if it's not after the inc)
*420 IF NW<>0 THEN 440
	mov @nw,r0
	jne l440
	
* Check if ladder (fixed location) needs to be drawn
* any object there prevents it!
*421 CALL GCHAR(1,5,QW) :: IF QW<>32 THEN 440
* not doing for ROM space, the vchar is fast enough

*425 RO=1 :: CO=5
*430 CALL GCHAR(RO,CO,QW) :: IF QW=32 THEN CALL HCHAR(RO,CO,128) :: RO=RO+1 :: GOTO 430
* unneeded, we'll just do a blind vchar, unless on level 5
	mov @le,r0
	ci r0,4
	jh l430b
	
    bl @vcharf
    byte 1,5,128,4
    byte 0,0
l430b
  
* main game loops around here
*435 GOTO 210
* Not done now, need the full loop

* if row (character) is less than 3, then we must have climbed to the top - do win routine
* newly, also check wafers and jumping to avoid cheating ;)
*440 IF RO<3 THEN 1000
l440
	mov @nw,r0
	jne l440b	  * still wafers left
	mov @ij,r0
	jne l440b     * not if jumping
	mov @ro,r0
	ci r0,3
	jl l1000
l440b

* check for ground underneath character - if none, fall (32 or 112)
* and then try to step off it.
*450 CALL GCHAR(RO+1,CO,QW) :: IF QW=32 THEN 2000
	mov @ro,r0
	inc r0
	mov @co,r1
	bl @gchar
	ci r2,32
	jeq l450b
	ci r2,112
	jeq l450b
	jmp l450c
l450b
	seto @ij		* start falling
	clr @rs			* zero gravity to start
l450c

*460 CALL COINC(ALL,QW) :: IF QW THEN 2000
	bl *r6
	mov r0,r0
	jeq l460b
	b @l2000
l460b
	
*470 GOTO 210
	b @l210
	
*1000 REM  NEXT LEVEL
l1000

* tally up bonus
	mov @bonus,r0
	jeq l1010

	li r12,>62f9
l1000b	
	bl @wradrf
	mov r12,@save
	mov @bonus,r13
	bl @disraw
	li r0,>2000
	movb r0,@>8C00
	
	bl *r6

	mov @save,r12
	dec r12
	ci r12,>62e6
	jne l1000b
	
	bl *r5
	byte 24,8,32,5,0,0
	
	a @bonus,@sc
	bl @disnum

*1010 LE=LE+1
l1010
	inc @le
	
*1015 IF LE=6 THEN 4000
	mov @le,r0
	ci r0,6
	jne l1015b
	b @l4000
l1015b

*1020 GOTO 150
	b @l150
	
*2000 REM  DIED!
l2000
* show the bonus in case it reached 0
	bl @disbonus

*2005 FOR A=4 TO 16 :: CALL MOTION(#A,0,0) :: NEXT A
	li r0,4
l2005b
	bl @fixmotion2
	byte 0,0
	inc r0
	ci r0,17
	jl l2005b

* I like it the way it is, sound effect, then fall. Lets you see what killed you.
*2010 FOR A=990 TO 110 STEP-110 :: CALL SOUND(-100,A,0) :: NEXT A
	bl @playsound
	data fallsound-firstsnd+>2500
	bl @waitsound		* this is one place I'd like to pause

* falling here
*2020 CALL PATTERN(#1,106) :: CALL MOTION(#1,16,0)
	li r1,106
	bl *r7			* pattern1
	
	bl @fixmotion
	byte 0,1,16,0

*2030 CALL POSITION(#1,RO,CO) :: IF RO<200 THEN 2030
l2030	
	bl *r6			* we insert a coinc call to make our framing work
	mov r8,r0
	bl @position
	ci r1,200
	jl l2030

*2040 CALL DELSPRITE(ALL)
	bl @dsprall
	
*2045 CALL HCHAR(23,4,32,5)
	bl *r5
	byte 23,4,32,5,0,0

*2050 NM=NM-1 :: CALL HCHAR(23,4,97,NM)
	dec @nm
	bl @showlives

*2060 IF NM=0 THEN 3000
	mov @nm,r0
	jeq l3000

*2070 GOTO 170
	clr @bonus
	b @l170
	
* game over!	
l3000
*3010 DISPLAY AT(12,8):"GAME OVER"
	bl @display
	byte 12,10
	data gameover

*3000 FOR A=1990 TO 110 STEP-110 :: CALL SOUND(-100,A,0,A*2,0) :: NEXT A
	bl @playsound
	data gameoversnd-firstsnd+>2500
	bl @waitsound
	
*3020 FOR A=1 TO 50 :: CALL KEY(C,K,S)
*3030 IF K=18 THEN 20
*3040 NEXT A :: GOTO 20
* loop replaced by playing the sound to save space
	b @l20
	
* play a little win chime	
*4000 FOR A=550 TO 1010 STEP 110 :: CALL SOUND(-100,A,0) :: NEXT A
l4000
	bl @playsound
	data gamewin-firstsnd+>2500
	bl @waitsound

* back down the ladder
*4010 FOR A=1 TO 4 :: CALL POSITION(#1,RO,CO) :: CALL LOCATE(#1,RO+8,CO) :: FOR B=1 TO 40 :: NEXT B :: NEXT A
	bl @animmove
	byte 0,2,128,13

	bl @animmove
	byte 2,0,136,16
	
*4015 CALL PATTERN(#1,99)
* not needed - loop below animates

* walk to the villian
*4020 FOR A=1 TO 13 :: CALL POSITION(#1,RO,CO) :: CALL LOCATE(#1,RO,CO-8) :: CALL PATTERN(#1,98+AN) :: AN=-(AN=0) :: FOR B=1 TO 40 :: NEXT B :: NEXT A
	bl @animmove
	byte 0,-2,132,52
	
	bl @cdelay
	data 5

* prepare to punch
*4030 CALL PATTERN(#1,111) :: FOR A=1 TO 200 :: NEXT A
	li r1,143
	bl *r7			* pattern1

	bl @cdelay
	data 10

* punch
*4040 CALL PATTERN(#1,113) :: CALL SOUND(100,-6,10)
	li r1,144
	bl *r7			* pattern1
	
	bl @playsound
	data punchsnd-firstsnd+>2500

* drop villian
*4050 CALL PATTERN(#2,110) :: CALL MOTION(#2,18,0)
	li r0,2
	li r1,113
	bl @pattern
	
	bl @fixmotion2
	byte 18,0

	bl @cdelay		* delay
	data 10

* unpunch
*4060 CALL PATTERN(#1,98)
	li r1,136
	bl *r7			* pattern1

* wait for villian fall to end
*4070 CALL POSITION(#2,RO,CO) :: IF RO<200 THEN 4070
l4070
	bl *r6			* run plus delay

	li r0,2
	bl @position
	ci r1,200
	jl l4070

* delete villian
*4080 CALL DELSPRITE(#2)
*	li r0,2
	bl @delspr
	
* move up to machine	
*4090 CALL POSITION(#1,RO,CO) :: CALL LOCATE(#1,RO,CO-8)
*4100 CALL LOCATE(#1,RO,CO-16)
	bl @animmove
	byte 0,-2,132,6

* wait	
*4110 FOR A=1 TO 200 :: NEXT A
	bl @cdelay
	data 40
	
* display '?'	
*4120 CALL HCHAR(4,5,63) :: FOR A=1 TO 300 :: NEXT A :: CALL HCHAR(4,5,32)
	bl *r5
	byte 4,5,63,1,0,0
	
	bl @cdelay
	data 10
	
	bl *r5
	byte 4,5,32,1,0,0
	
	bl *r6

* prepare to punch
*4130 CALL PATTERN(#1,111)
	li r1,143
	bl *r7			* pattern1

*4140 FOR A=1 TO 50 :: NEXT A
	bl @cdelay
	data 10

* punch
*4150 CALL PATTERN(#1,113)
	li r1,144
	bl *r7			* pattern1
	
*4160 CALL SOUND(100,-6,4)
	bl @playsound
	data punchsnd-firstsnd+>2500
	
* break machine and unpunch	
*4170 CALL HCHAR(6,3,121) :: CALL PATTERN(#1,98)
* erase 'help' too
*4175 DISPLAY AT(1,10):"    ";
	bl *r5
	byte 6,3,146,1
	byte 1,12,32,4,0,0
	
	bl @cdelay
	data 10
	
	li r1,136
	bl *r7			* pattern1
	
* turn off all the enemies	
*4180 FOR A=4 TO 16 :: CALL DELSPRITE(#A) :: NEXT A
	li r0,4
l4180b
	bl @delspr
	inc r0
	ci r0,17
	jl l4180b
	
	bl @cdelay
	data 10

* move back to ladder
*4190 FOR A=1 TO 15 :: CALL PATTERN(#1,96+AN) :: AN=-(AN=0) :: CALL POSITION(#1,RO,CO) :: CALL LOCATE(#1,RO,CO+8) :: FOR B=1 TO 50 :: NEXT B :: NEXT A
	bl @animmove
	byte 0,2,128,58

*4200 CALL PATTERN(#1,100)
* not needed - animation below handles it
	
* move up ladder
*4210 FOR A=1 TO 4 :: CALL POSITION(#1,RO,CO) :: CALL LOCATE(#1,RO-8,CO) :: FOR B=1 TO 20 :: NEXT B :: NEXT A
	bl @animmove
	byte -2,0,136,16

*4220 CALL PATTERN(#1,98)
* Not needed - animation below gets it

* move to girl
*4230 FOR A=1 TO 4 :: CALL POSITION(#3,RO,CO) :: CALL LOCATE(#3,RO,CO-8) :: FOR B=1 TO 75 :: NEXT B :: NEXT A
	bl @animmove
	byte 0,-2,132,14

* heart <3
*4240 CALL SPRITE(#4,114,9,1,94)
	bl @sprite
	byte 4,1,94,114,8,0
	
* pointless happy tune	
*4250 B=330
*4260 FOR A=1 TO 3
*4270 CALL SOUND(300,B,0)
*4280 CALL SOUND(300,B+55,0)
*4290 CALL SOUND(300,B+20,0)
*4300 CALL SOUND(300,B+75,0)
*4310 B=B+110
*4320 NEXT A
*4330 CALL SOUND(300,B+110,0)
*4340 CALL SOUND(300,B,0)
*4350 CALL SOUND(300,B-110,0)
	bl @playsound
	data happysnd-firstsnd+>2500
	bl @waitsound
	
*4360 FOR A=1 TO 300 :: NEXT A
	bl @cdelay
	data 30
	
*4370 DISPLAY AT(9,10):"BONUS= 100 X"
	bl @display
	byte 9,10
	data bonustxt

*4380 CO=25
	li r0,25
	mov r0,@co
	
*4390 FOR A=1 TO NM :: CALL SOUND(100,1000,0) :: CALL HCHAR(9,CO,97) :: SC=SC+100 :: DISPLAY AT(24,1):SC
l4390b
	mov @nm,r0
	jeq l4400b
	
	bl @playsound
	data tallysnd-firstsnd+>2500
	
	li r0,9
	mov @co,r1
	li r2,136
	bl @hchar1
	
	li r0,100
	a r0,@sc
	
	bl @disnum
	
*4400 CALL HCHAR(23,4,32,5) :: NM=NM-1 :: CALL HCHAR(23,4,97,NM) :: CO=CO+1 :: NEXT A
	bl *r5
	byte 23,4,32,5,0,0
	
	dec @nm

	bl @showlives

	inc @co
	
	bl @cdelay
	data 20
	
	jmp l4390b
l4400b
	
*4410 FOR A=1 TO 1000 :: CALL KEY(C,K,S) :: IF K=18 THEN 20
	mov r8,@a
l4410b
	mov @a,r0
	ci r0,2000
	jh l4420b
	
	bl *r6			* slow it down a bit, this is just a timeout delay
	bl @scan
	bl @key
*	ci r1,18    * done in key
	jne l4420
	b @l20

*4420 NEXT A :: GOTO 20
l4420
	inc @a
	jmp l4410b
l4420b
	b @l20
	
* replacing subs with gosub...

*10000 SUB INIT
CDAT BYTE >60,>D0,>10,>a0

*10130 SUB DRAW(X) - always LE
DRAW
	mov r11,r15

*10135 CALL CLEAR
	bl @clear
	
*10140 ON X GOTO 10160,10300,10400,10500,10600
	mov @le,r0
	dec r0
	sla r0,1
	ai r0,JTABLE
	mov *r0,r0
	b *r0

JTABLE
	DATA l10160,l10300,l10400,l10500,l10600

** Level 1 **
*10160 CALL HCHAR(5,1,105,32)
*10170 CALL HCHAR(10,1,105,32)
*10180 CALL HCHAR(15,1,105,32)
*10190 CALL HCHAR(22,1,105,32)
*10240 CALL HCHAR(4,5,112)
*10250 CALL HCHAR(9,30,112)
*10260 CALL HCHAR(14,3,112)
*10270 CALL HCHAR(21,30,112)
l10160
	bl *r5
	byte 5,1,105,32
	byte 10,1,105,32
	byte 15,1,105,32
	byte 22,1,105,32
	byte 4,5,112,1
	byte 9,30,112,1
	byte 14,3,112,1
	byte 21,30,112,1
	byte 0,0
		
*10210 CALL VCHAR(4,29,128,6)
*10220 CALL VCHAR(9,4,128,6)
*10230 CALL VCHAR(14,29,128,8)
	bl @vcharf
	byte 4,29,128,6  * tweaked
	byte 9,4,128,6
	byte 14,29,128,8
	byte 0,0
	
*10280 SUBEXIT
	b *r15
	
** Level 2 **	
*10300 CALL HCHAR(5,1,105,32)
*10310 CALL HCHAR(10,1,105,32)
*10320 CALL HCHAR(15,1,105,32)
*10330 CALL HCHAR(22,1,105,32)
*10350 CALL HCHAR(4,27,112)
*10360 CALL HCHAR(9,27,112)
*10370 CALL HCHAR(14,27,112)
*10380 CALL HCHAR(21,27,112)
l10300
	bl *r5
	byte 5,1,105,32
	byte 10,1,105,32
	byte 15,1,105,32
	byte 22,1,105,32
	byte 4,27,112,1
	byte 9,27,112,1
	byte 14,27,112,1
	byte 21,27,112,1
	byte 0,0

*10340 CALL VCHAR(3,5,128,19)
	bl @vcharf
	byte 3,5,128,19
	byte 0,0
	
*10390 SUBEXIT
	b *r15

** Level 3 **	
*10400 CALL HCHAR(4,1,105,32)
*10405 CALL HCHAR(10,1,105,32)
*10410 CALL HCHAR(17,1,105,32)
*10415 CALL HCHAR(22,3,105,6)
*10420 CALL HCHAR(21,11,105,6)
*10425 CALL HCHAR(20,19,105,6)
*10445 CALL HCHAR(3,31,112)
*10450 CALL HCHAR(9,2,112)
*10455 CALL HCHAR(16,30,112)
*10460 CALL HCHAR(20,14,112)
l10400
	bl *r5
	byte 5,1,105,32
	byte 10,1,105,32
	byte 17,1,105,32
	byte 22,3,105,6
	byte 21,11,105,6
	byte 20,19,105,6
	byte 4,31,112,1
	byte 9,2,112,1
	byte 16,30,112,1
	byte 20,14,112,1
	byte 0,0
	
*10430 CALL VCHAR(3,29,128,7)
*10435 CALL VCHAR(9,4,128,8)
*10440 CALL VCHAR(16,23,128,4)
	bl @vcharf
	byte 4,29,128,6
	byte 9,4,128,8
	byte 16,23,128,4
	byte 0,0
	
*10465 SUBEXIT
	b *r15

** Level 4 **
*10500 CALL HCHAR(4,7,105,12)
*10505 CALL HCHAR(4,21,105,4)
*10510 CALL HCHAR(4,27,105,4)
*10515 CALL HCHAR(7,3,105,6)
*10520 CALL HCHAR(7,11,105,20)
*10525 CALL HCHAR(10,1,105,32)
*10530 CALL HCHAR(14,3,105,22)
*10535 CALL HCHAR(14,27,105,4)
*10540 CALL HCHAR(20,15,105,10)
*10545 CALL HCHAR(21,9,105,10)
*10550 CALL HCHAR(22,3,105,10)
*10575 CALL HCHAR(13,4,112)
*10580 CALL HCHAR(6,28,112)
*10585 CALL HCHAR(3,23,112)
*10590 CALL HCHAR(3,29,112)
l10500
	bl *r5
	byte 4,7,105,12
	byte 4,21,105,4
	byte 4,27,105,4
	byte 7,3,105,6
	byte 7,11,105,20
	byte 10,1,105,32
	byte 14,3,105,22
	byte 14,27,105,4
	byte 20,15,105,10
	byte 21,9,105,10
	byte 22,3,105,10
	byte 13,4,112,1
	byte 6,28,112,1
	byte 3,23,112,1
	byte 3,29,112,1
	byte 0,0
	
*10555 CALL VCHAR(3,8,128,4)
*10560 CALL VCHAR(6,5,128,4)
*10565 CALL VCHAR(9,29,128,5)
*10570 CALL VCHAR(13,23,128,7)
*10573 CALL VCHAR(3,30,128,4)
	bl @vcharf
	byte 3,8,128,4
	byte 5,5,128,5
	byte 9,29,128,5
	byte 13,23,128,7
	byte 3,30,128,4
	byte 0,0
	
*10595 SUBEXIT
	b *r15
	
** Level 5 **	
*10600 CALL HCHAR(3,9,105,12)
*10605 CALL HCHAR(7,3,105,28)
*10610 CALL HCHAR(12,3,105,28)
*10615 CALL HCHAR(17,3,105,28)
*10620 CALL HCHAR(22,3,105,28)
l10600
	bl *r5
	byte 3,9,105,12
	byte 7,3,105,28
	byte 12,3,105,28
	byte 17,3,105,28
	byte 22,3,105,28
	byte 2,15,112,4      * 4 wafers to clear the stage
	byte 0,0

*10625 CALL VCHAR(2,19,128,5)
*10630 CALL VCHAR(6,29,128,6)
*10635 CALL VCHAR(11,4,128,6)
*10640 CALL VCHAR(16,29,128,6)
*10645 CALL VCHAR(4,3,120,3)
	bl @vcharf
	byte 2,19,128,5
	byte 6,29,128,6
	byte 11,4,128,6
	byte 16,29,128,6
	byte 4,3,145,3
	byte 0,0
	
*10650 DISPLAY AT(1,10):"HELP"
	bl @display
	byte 1,10
	data helphelp
	
*10655 SUBEND
	b *r15
	
*10700 SUB SHAPES(X) - always 'LE'
SHAPES
	mov r11,r10

*10710 ON X GOTO 10720,10800,10900,11000,12000
	mov @le,r0
	dec r0
	sla r0,1
	ai r0,JTAB2
	mov *r0,r0
	b *r0
	
JTAB2 data l10720,l10800,l10900,l11000,l12000

** Level 1 **
*10720 FOR A=1 TO 3 :: CALL SPRITE(#A+3,101,5,16,A*80,0,5) :: NEXT A
*10730 FOR A=1 TO 3 :: CALL SPRITE(#A+6,101,5,56,A*80,0,-5) :: NEXT A
*10740 FOR A=1 TO 3 :: CALL SPRITE(#A+9,101,5,96,A*80,0,5) :: NEXT A
*10750 FOR A=1 TO 3 :: CALL SPRITE(#A+12,101,5,152,A*80,0,-5) :: NEXT A
*10760 SUBEXIT

l10720
	bl @vdpcpy
	data >430c,SDAT1,48
	
	BL @VDPSETF
	data >478c
	byte 0,128
	
	LI R12,>478D
	LI R13,>0500
	LI R14,3
	li r15,4

* write 4 sets of three, inverting 5/-5 each time
l10720b
	bl @wradrf
	ai r12,4
	movb r13,*r4
	dec r14
	jne l10720b
	li r14,3
	inv r13
	ai r13,>0100		* byte-wise neg
	dec r15
	jne l10720b
	
	b *r10

SDAT1
	BYTE 15,80,147,4,15,160,147,4,15,240,147,4
	byte 55,80,147,4,55,160,147,4,55,240,147,4
	byte 95,80,147,4,95,160,147,4,95,240,147,4	
	byte 151,80,147,4,151,160,147,4,151,240,147,4

** Level 2 **
*10800 FOR A=1 TO 2 :: CALL SPRITE(#A+3,101,5,16,A*100,0,5) :: NEXT A
*10810 FOR A=1 TO 2 :: CALL SPRITE(#A+5,101,5,56,A*100,0,-5)
*10815 NEXT A
*10820 FOR A=1 TO 2 :: CALL SPRITE(#A+7,101,5,96,A*100,0,5) :: NEXT A
*10830 FOR A=1 TO 2 :: CALL SPRITE(#A+9,101,5,152,A*100,0,-5) :: NEXT A
*10840 SUBEXIT

l10800
	bl @vdpcpy
	data >430c,SDAT2,32
	
	BL @VDPSETF
	data >478c
	byte 0,128
	
	LI R12,>478D
	LI R13,>0500
	LI R14,2
	li r15,4

* write 4 sets of two, inverting 5/-5 each time
l10800b
	bl @wradrf
	ai r12,4
	movb r13,*r4
	dec r14
	jne l10800b
	li r14,2
	inv r13
	ai r13,>0100		* byte-wise neg
	dec r15
	jne l10800b
	
	b *r10

SDAT2
	byte 15,100,147,4,15,200,147,4
	byte 55,100,147,4,55,200,147,4
	byte 95,100,147,4,95,200,147,4
	byte 151,100,147,4,151,200,147,4

** Level 3 **
*10900 FOR A=1 TO 3 :: CALL SPRITE(#A+3,101,5,8,A*80,0,5) :: NEXT A
*10910 FOR A=1 TO 3 :: CALL SPRITE(#A+6,101,5,56,A*80,0,-5) :: NEXT A
*10920 FOR A=1 TO 3 :: CALL SPRITE(#A+9,101,5,112,A*80,0,5) :: NEXT A
*10930 CALL SPRITE(#13,103,3,136,100,0,-5)
*10940 SUBEXIT

l10900
	bl @vdpcpy
	DATA >430c,SDAT3,40
	
	BL @VDPSETF
	data >478c
	byte 0,128
	
	LI R12,>478D
	LI R13,>0500
	LI R14,3
	li r15,4

* write 4 sets of three, inverting 5/-5 each time
l10900b
	bl @wradrf				* note: only 1 sprite in the last set, hopefully won't break ;)
	ai r12,4
	movb r13,*r4
	dec r14
	jne l10900b
	li r14,3
	inv r13
	ai r13,>0100		* byte-wise neg
	dec r15
	jne l10900b
	
	b *r10

SDAT3
	byte 15,80,147,4,15,160,147,4,15,240,147,4
	byte 55,80,147,4,55,160,147,4,55,240,147,4
	byte 111,80,147,4,111,160,147,4,111,240,147,4
	byte 135,100,100,3

** Level 4 **
*11000 CALL SPRITE(#4,101,14,8,100)
*11010 CALL SPRITE(#6,103,3,32,100,0,-5)
*11020 FOR A=1 TO 3 :: CALL SPRITE(#A+6,101,5,56,A*80,0,5) :: NEXT A
*11030 CALL SPRITE(#10,103,3,88,80,0,-5)
*11040 SUBEXIT

l11000
	bl @vdpcpy
	DATA >430C,SDAT4,28
	
	BL @VDPSETF
	data >478c
	byte 0,128

* these setups rely on side effects, that r0 etc are set by previous calls	
	bl @fixmotion
	byte 0,6,0,-5

	li r0,10
	bl *r9

	bl @fixmotion
	byte 0,7,0,5

	inc r0
	bl *r9

	inc r0
	bl *r9
	
	b *r10

SDAT4
	byte 7,100,147,13,>d2,0,0,0,31,100,100,3
	byte 55,80,147,4,55,160,147,4,55,240,147,4
	byte 87,80,100,3

** Level 5 **
*12000 CALL SPRITE(#2,108,2,32,24)
*12010 CALL SPRITE(#3,107,10,1,72)
*12020 CALL SPRITE(#4,102,3,56,100,0,5)
*12030 FOR A=1 TO 2 :: CALL SPRITE(#A+4,104,15,81,A*80,0,-5) :: NEXT A
*12040 CALL SPRITE(#7,103,3,96,100,0,-5)
*12050 CALL SPRITE(#8,104,15,121,100,0,5)
*12060 CALL SPRITE(#9,102,3,136,50,0,5)
*12070 CALL SPRITE(#10,104,15,161,100,0,-5)
*12080 SUBEND

l12000
	bl @vdpcpy
	DATA >4304,SDAT5,36
	
	BL @VDPSETF
	data >4784
	byte 0,128

* these setups rely on side effects, that r0 etc are set by previous calls	
	bl @fixmotion
	byte 0,4,0,5
	
	li r0,8
	bl *r9

	inc r0
	bl *r9

	bl @fixmotion
	byte 0,5,0,-5

	inc r0
	bl *r9

	inc r0
	bl *r9

	li r0,10
	bl *r9
	
	b *r10

SDAT5
	byte 31,23,108,1,1,72,107,9,55,100,96,2
	byte 79,80,104,14,79,160,104,14
	byte 95,100,100,3,119,100,104,14,135,50,96,2
	byte 159,100,104,14

**********************************
* Extended BASIC Porting support *
* by Tursi                       *
**********************************

************************************
* VDP support for the XB functions *
************************************

* non-bitmap mode, ext video off
* 16k, screen on, ints on, magnify 1 (differs from XB)
* different from XB - SDT at >2000
* different from XB - CT at >1000
* different from XB - PDT at >0800
* SAT at >0300 (motion table at >0780, fixed)
* different from XB - SPT at >0800
* transparent on XB color 15
VDPTAB  DATA >E108,>4001,>0601,>0E00

* Write address - address is data after the fact
WRADR
		MOV *r11+,r12
    
* write address - R12 has word ready to write with tags
WRADRF
		SWPB R12
		MOVB R12,@>8C02
		SWPB R12
		MOVB R12,@>8C02
		B *R11
		
* vdpsetf takes the address, byte and the count as bytes after the call
* count of 255 or fewer bytes
VDPSETF
    mov *r11+,r12
    mov r11,r13
    bl @wradrf
    mov r13,r11
		movb *r11+,R12
		movb *r11+,R13
		SRL R13,8
* write byte in R12 MSB R13 times to VDP
VDPSET	MOVB R12,*r4
		DEC R13
		JNE VDPSET
		B *R11

* XB-LIKE FUNCTIONS - REGS 0+ FOR INPUTS, BL TO CALL
* MUST PRESERVE REGS, BUT CAN USE R10,R12-R14

CLEAR	mov r11,r10
		bl @dsprall
		bl @wradr
		data >6000
		LI R12,>2000
		LI R13,>500   * 512 bytes padding for jump wraparound
		BL @VDPSET
		B *R10
		
* DISPADR - Set the write VDP address for a display function
* 1=ROW+1,2=COL-1 (28 col print)
* followed by data bytes, row,col, data
* r14 is the parent pointer
DISPADR
		movb *R14+,R12
		SRL R12,8
		DEC R12
		SLA R12,5
		ab *r14+,@>8319		* I think this should always be safe, no wrap
		INC R12
		ORI R12,>6000
		B @WRADRF		* just branch, so it returns for us
		
*DISPLAY	0=STRING (>80 TERMINATED),1=ROW+1,2=COL-1 (28 col print)
* data: row,col,address
DISPLAY	MOV R11,R14
		BL @DISPADR
		MOV *r14+,R12
DSLP1	MOVB *R12+,R13
		JLT DSEXIT
		MOVB R13,*r4
		JMP DSLP1
DSEXIT	B *R14

* disraw - entry at DISNUM2 without other setting
* used in the bonus tally
disraw
		mov r11,r14
		jmp disnum2

* DISBONUS - @bonus at 24,24
disbonus
		mov r11,r14
		bl @wradr
		data >62fa		* 24,26
		mov @bonus,r13
		jmp disnum2

*DISNUM	@SC, at 24,1 (XB offsets) (28 col print)
*DISNUM2 - set address yourself, load value into R13
DISNUM	MOV R11,R14
		BL @wradr
		data >62e2      * 24,3
		MOV @SC,R13		* dividend
DISNUM2		
		LI R11,10000	* divisor
DNUMLP	
		CLR R12			* prepare for DIV
		DIV R11,R12		* R12=result, R13=remainder
		AI R12,48		* make ASCII
		SWPB R12		* make MSB
		MOVB R12,*R4	* write to screen (no 0 suppress)
		
		CLR R10			* prepare for DIV
		LI R12,10		* divisor
		DIV R12,R10		* R10=result, R11=remainder (should be zero)
		MOV R10,R11		* are we done?
		JNE DNUMLP
		B *R14
		
*CHAR	0=CHAR, 1=NUMBER OF BYTES, 2=ADDRESS OF BYTES
* Data statements after the call
CHAR	MOV R11,R14
		movb *r14+,R12

		SRL R12,8
		SLA R12,3
		AI R12,>4800
		bl @wradrf	* this handles the return

		movb *r14+,R13
		SRL R13,8
		mov *r14+,r12
CHAR2
		MOVB *R12+,*r4  *inline vdpcpy since vdpcpy isn't embeddable now
		DEC R13
		JNE CHAR2
		B *R14
		
* VDP Copy - follow with VDP adr, CPU addr, byte count (word)
VDPCPY
    MOV R11,R14
    MOV *R14+,R12
    BL @wradrf
    mov *r14+,r12
    mov *r14+,r13
VDPCP1	
    MOVB *R12+,*r4
		DEC R13
		JNE VDPCP1
		B *R14
		
* HCHARADR (also for vchar, gchar, etc)
* R0,R1 to R12 for read
* pass in a value to add (0 for read, >4000 for write)
HCHARADR
		MOV R0,R12
		DEC R12
		ANDI R12,>00FF
		SLA R12,5
		A R1,R12
		DEC R12
		AI R12,>2000
		A *R11+,R12
		B *R11
		
* HCHARF - fixed value hchar
* the four values, as bytes, are at the return address
* we have a lot of hchars... count==0 is illegal
* continues till it finds a 0 byte for row, skips the next
* byte too for an even return address.
HCHARF
		mov r11,r10
		movb *r10+,r0
HCHARF2
		srl r0,8
		movb *r10+,r1
		srl r1,8
		movb *r10+,r2
		srl r2,8
		movb *r10+,r3
		srl r3,8
		bl @hchar
		movb *r10+,r0
		jne HCHARF2
		inc r10
		b *r10
	
*HCHAR1 0,1,2 - single character hchar wrapper
HCHAR1	MOV R8,R3	* LOADS 1 - LI R3,1
* fall through into hchar

*HCHAR	0,1,2,3 (ALL EXCEPT 2 and 3 ARE +1)
HCHAR	MOV R11,R14
		BL @HCHARADR
		DATA >4000
		bl @wradrf
		MOV R2,R12
		SWPB R12
		MOV R3,R13
		JEQ HCHAROUT
		BL @VDPSET
HCHAROUT		
		B *R14

*GCHAR	0=ROW,1=COL, RETURN IN 2
GCHAR	MOV R11,R14
		bl @hcharadr
		DATA >0000
		bl @wradrf
		MOVB @>8800,R2
		srl r2,8
		B *R14
		
* scan - wrapped call to KSCAN
* after this, KEY and JOYST just read the return variables
SCAN
		movb @>8311,@>8374	* R8 LSB - mode 1 - scans keyboard and joystick
		lwpi >83e0		* GPLWS
		bl @>000e		* scan
		lwpi >8300
		b *r11
		
*KEY  Scan must be called first - key in R1, RETURN EQ if fire is pressed
KEY	
		movb @>8375,r1
		SRL r1,8
		CI R1,18
		b *r11
		
* DSPRALL	DELETES ALL SPRITES
DSPRALL	MOV R11,R14
		BL @VDPSETF
		data >4300
		byte >e1,128
* and the automotion table
		BL @VDPSETF
		data >4780
		BYTE 0,128
		B *R14

* VCHARF - fixed value vchar
* the four values, as bytes, are at the return address
* we have a lot of hchars...
VCHARF
		mov r11,r10
		movb *r10+,r0
VCHARF2		
		srl r0,8
		movb *r10+,r1
		srl r1,8
		movb *r10+,r2
		srl r2,8
		movb *r10+,r3
		srl r3,8
		
* inline vchar
		bl @hcharadr
		DATA >4000
		MOV R3,R13
		JEQ VCHAROUT
		SWPB R2
VCHAR1	bl @wradrf
		MOVB R2,*r4
		AI R12,32
		DEC R13
		JNE VCHAR1
*		SWPB R2				* this one doesn't need to preserve r2
VCHAROUT		

		movb *r10+,r0
		jne VCHARF2
		inc r10
		b *R10

* get sprite vdp address from sprite r0 to r12
SPRITEADR
		MOV R0,R12
		DEC R12
		SLA R12,2
		AI R12,>4300
		B *R11
		
* SPRITE 0=SPRITE+1, 1=ROW+2, 2=COL+1, 3=CHARACTER, 4=COLOR
* passed as data bytes, not registers, color is NOT plus 1!
SPRITE	MOV R11,R14
		movb *r14+,r0
		srl r0,8
		bl @SPRITEADR
		bl @wradrf
		movb *r14+,r12
		ai r12,->0200
		MOVB R12,*r4
		movb *r14+,r12
		ai r12,->0100
		MOVB R12,*r4
		movb *r14+,*r4
		movb *r14+,*r4
		inc r14
		B *R14

* LOCATE 0=SPRITE+1, 1=ROW+2, 2=COL+1
LOCATE	MOV R11,R14
		bl @spriteadr
		bl @wradrf
		MOV R1,R12
		DECT R12			* TOP LINE IS -1, NOT 1
		SWPB R12
		MOVB R12,*r4
		ai r2,-3
		MOV R2,R12
		ai r2,3
		DEC R12				* LEFT COL IS 0, NOT 1
		SWPB R12
		MOVB R12,*r4
		B *R14

* POSITION 0=SPRITE+1, RETURN: 1=ROW+2, 2=COL+1
POSITION
		MOV R11,R14
		bl @spriteadr
		andi r12,>3fff    * want a read address
		bl @wradrf
		MOVB @>8800,R1
		SRL R1,8
		MOVB @>8800,R2
		SRL R2,8
		AI R2,3		  * positioning offset - hacky but helps the original alignment code
		INCT R1       * fix top line offset (-1 to 1)
		ANDI R1,>00FF * mask it, it's supposed to wrap around
		INC R2        * fix left column (0 to 1) (256 is okay)
		B *R14

* POSITIONRAW - same as POSITION but stores in RO,CO
POSITIONRAW
    MOV R11,R10
    BL @POSITION
  	mov r1,@ro
	mov r2,@co
	b *r10

* Pattern for player 1 (loads R0)
* this is called by R7
PATTERN1
	mov r8,r0

* PATTERN 0 = SPRITE+1, 1=CHARACTER CODE
PATTERN	MOV R11,R14
		MOV R0,R12
		DEC R12
		SLA R12,2
		AI R12,>0302
		ORI R12,>4000
		bl @wradrf
		MOVB @>8303,*r4  * R1 LSB
		B *R14
		
* COINC - (only ALL) return non-zero in r0 if set - uses cached copy, ints must run!
COINC 
* we do the frame interrupt inline here - this is called every game frame!
* we use R0 for scratch because we return r0 anyway
		clr @>83d6
INTWAIT		
		limi 2
		limi 0
		mov @>83d6,r0
		jeq intwait

* inline anim - uses temp workspace!
* sprite enemy animation. we can skip #1 (player) and #2 (boss)
* the rest we sort of cheat and do by color
* 2 = bird	
* 4 = worm	147
* kind of wasteful I guess, but it works
spranim
		lwpi >8380		* GPL stack, should be safe - all regs free
		
		li r12,>030B	* color of sprite 3

		bl @animframe	* loads R1 with 1-4
		li r13,95		* bird right
		a r1,r13
		li r14,146		* worm
		a r1,r14
		ai r1,99		* bird left
		
		li r2,13		* highest sprite used is #15
		clr r3

sprlp
		bl @WRADRF
		movb @>8800,r3
		ci r3,>0200
		jne notbird1

* bird right here
		li r0,>839b			* LSB R13
		jmp changeit

notbird1
		ci r3,>0300
		jne notbird2

* bird left here
		li r0,>8383			* LSB R1
		jmp changeit

notbird2
		ci r3,>0400
		jne notworm

* worm here
		li r0,>839d			* LSB R14
		jmp changeit

notworm
		ai r12,4		* skip ahead to next sprite
		dec r2
		jne sprlp
		jmp sprdone

* changes the sprite pattern from address r0
changeit		
		dect r12
		bl @wradrf			* sets read address and auto-increments
		movb *r0,@>8c00
		inct r12
		jmp notworm
		
sprdone
		lwpi >8300			* back to default

* this is the actual coinc now
		movb @>837b,r0
* todo: dynamic cheat?		
		andi r0,>2000
* THIS LINE IS CHEATING
*		andi r0,>0000
		B *R11

* CDELAY - data = number of times to call COINC
CDELAY
		mov r11,r14
		mov *r14+,12
CDELAY1
		bl *r6
		dec r12
		jne cdelay1
		b *R14
		
* fixmotion - 0,sprite,rs,cs as data
* fixmotion2 skips the 0 and the sprite
fixmotion
		inc r11
		movb *r11+,r0
		srl r0,8
fixmotion2		
		movb *r11+,r1
		sra r1,8
		movb *r11+,r2
		sra r2,8

* MOTION 0=sprite+1, 1=row speed, 2=column speed
MOTION
		MOV R11,R14
		bl @spriteadr
		AI R12,>0480   * need motion table
		bl @wradrf
		movb @>8303,*r4  * R1 LSB
		movb @>8305,*r4  * R2 LSB
* we know R0 MSB must be zero
		movb r0,*r4
		movb r0,*r4
		B *R14

*delspr - r0 = sprite+1
DELSPR
		MOV R11,R14
		bl @spriteadr
		bl @wradrf
		li r13,>E100			* sprite automotion doesn't allow values from c1-e0
		movb r13,*r4
		ai r12,>0480
		bl @wradrf
* we know r0 msb must be zero
		movb r0,*r4
		movb r0,*r4
		movb r0,*r4
		movb r0,*r4

		b *r14

waitnewkey
		mov r11,r10
waitA		
		bl @scan
		bl @key
*		ci r1,18  (done in key)
		jeq waitA
waitB	
		bl *r6		* delays and sound processing!
		bl @scan
		bl @key
*		ci r1,18 * done in key
		jne waitB
		
		B *r10

* converts sprite pixel coordinates to chars
* RO returns in r0, CO returns in r1 (each /8+1)		
pix2char
		mov @ro,r0
		srl r0,3
		inc r0
		mov @co,r1
		srl r1,3
		inc r1
		B *r11
		
* snap ro,co functions, also calls locate
snaprow
		mov @ro,r1
		andi r1,>f8
		inc r1
		mov @co,r2
snapcommon
		mov r8,r0
		b @locate

snapcol
		mov @co,r2
		andi r2,>f8
		jmp snapcommon

* return 1-4 (no 0) in r1 for an animation frame
animframe
		movb @>8379,r1		* interrupt counter
		srl r1,10
		andi r1,3
		inc r1
		b *R11

* display the number of lives remaining
showlives
		li r0,23
		li r1,4
		li r2,136
		mov @nm,r3
		b @hchar		* hchar handles the return for us

* start a sound list on the ISR
* pass the VDP address in the data statement
playsound
		mov *r11+,@>83cc	* set pointer to VDP sound list
		socb @>8311,@>83fd	* set the 'vdp' source flag bit (R8 LSB)
		movb @>8311,@>83ce	* start sound processing
		b *r11
		
* wait for any active playlist to finish
waitsound
		mov r11,r10
waitsnd1
		bl *r6
		movb @>83ce,r0
		jne waitsnd1
		
		b *r10

* animmove - animated move of the player sprite,
* used for the final animation. data statement
* after the call should include row add, column add,
* base character (animated 1-4) and number of frames
* getting hard to find free registers...
animmove
* load the variables
		movb *r11+,r10		* row step
		sra r10,8
		movb *r11+,r13		* col step
		sra r13,8
		movb *r11+,r15		* base character
		srl r15,8
		movb *r11+,r3		* frames
		srl r3,8

* save return
		mov r11,@save
	
* and away we go!
animlp1
		mov r8,r0
		bl @position		* position lands in r1,r2
		a r10,r1
		a r13,r2
		bl @locate			* update position
		bl @animframe		* r1 = 1-4
		a r15,r1
		bl *r7				* update frame (pattern1)
		bl *r6				* coinc and delay
		
		dec r3
		jne animlp1
		
		mov @save,r11
		B *r11
			
		END

